"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@floating-ui";
exports.ids = ["vendor-chunks/@floating-ui"];
exports.modules = {

/***/ "(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@floating-ui/core/dist/floating-ui.core.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   rectToClientRect: () => (/* reexport safe */ _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n  const alignmentAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n  const alignLength = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(alignmentAxis);\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n  const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentAxis)(placement);\n    const length = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAxisLength)(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment), ...allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) !== alignment)] : allowedPlacements.filter(placement => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement) === alignment || (autoAlignment ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAlignmentPlacement)(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const initialSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(initialPlacement);\n      const isBasePlacement = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositePlacement)(initialPlacement)] : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getExpandedPlacements)(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxisPlacements)(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignmentSides)(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          const ignoreCrossAxisOverflow = checkCrossAxis === 'alignment' ? initialSideAxis !== (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(nextPlacement) : false;\n          if (!ignoreCrossAxisOverflow ||\n          // We leave the current main axis only if every placement on that axis\n          // overflows the main axis.\n          overflowsData.every(d => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {\n            // Try next placement and re-run the lifecycle.\n            return {\n              data: {\n                index: nextIndex,\n                overflows: overflowsData\n              },\n              reset: {\n                placement: nextPlacement\n              }\n            };\n          }\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return _floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\nfunction getBoundingRect(rects) {\n  const minX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.left));\n  const minY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...rects.map(rect => rect.top));\n  const maxX = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.right));\n  const maxY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.rectToClientRect)(getBoundingRect(nativeClientRects));\n      const paddingObject = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getPaddingObject)(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if ((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement) === 'left';\n          const maxRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(...clientRects.map(rect => rect.right));\n          const minLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\nconst originSides = /*#__PURE__*/new Set(['left', 'top']);\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n  const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n  const isVertical = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n  const mainAxisMulti = originSides.has(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.clamp)(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement);\n      const mainAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getOppositeAxis)(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = originSides.has((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.evaluate)(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSide)(placement);\n      const alignment = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getAlignment)(placement);\n      const isYAxis = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.getSideAxis)(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.min)(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, 0);\n        const xMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.right, 0);\n        const yMin = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, 0);\n        const yMax = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_0__.max)(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2NvcmUvZGlzdC9mbG9hdGluZy11aS5jb3JlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXNVO0FBQ2hSO0FBRXRELFNBQVNtQiwwQkFBMEJBLENBQUNDLElBQUksRUFBRUMsU0FBUyxFQUFFQyxHQUFHLEVBQUU7RUFDeEQsSUFBSTtJQUNGQyxTQUFTO0lBQ1RDO0VBQ0YsQ0FBQyxHQUFHSixJQUFJO0VBQ1IsTUFBTUssUUFBUSxHQUFHekIsK0RBQVcsQ0FBQ3FCLFNBQVMsQ0FBQztFQUN2QyxNQUFNSyxhQUFhLEdBQUd6QixvRUFBZ0IsQ0FBQ29CLFNBQVMsQ0FBQztFQUNqRCxNQUFNTSxXQUFXLEdBQUd6QixpRUFBYSxDQUFDd0IsYUFBYSxDQUFDO0VBQ2hELE1BQU1FLElBQUksR0FBR3pCLDJEQUFPLENBQUNrQixTQUFTLENBQUM7RUFDL0IsTUFBTVEsVUFBVSxHQUFHSixRQUFRLEtBQUssR0FBRztFQUNuQyxNQUFNSyxPQUFPLEdBQUdQLFNBQVMsQ0FBQ1EsQ0FBQyxHQUFHUixTQUFTLENBQUNTLEtBQUssR0FBRyxDQUFDLEdBQUdSLFFBQVEsQ0FBQ1EsS0FBSyxHQUFHLENBQUM7RUFDdEUsTUFBTUMsT0FBTyxHQUFHVixTQUFTLENBQUNXLENBQUMsR0FBR1gsU0FBUyxDQUFDWSxNQUFNLEdBQUcsQ0FBQyxHQUFHWCxRQUFRLENBQUNXLE1BQU0sR0FBRyxDQUFDO0VBQ3hFLE1BQU1DLFdBQVcsR0FBR2IsU0FBUyxDQUFDSSxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUdILFFBQVEsQ0FBQ0csV0FBVyxDQUFDLEdBQUcsQ0FBQztFQUMxRSxJQUFJVSxNQUFNO0VBQ1YsUUFBUVQsSUFBSTtJQUNWLEtBQUssS0FBSztNQUNSUyxNQUFNLEdBQUc7UUFDUE4sQ0FBQyxFQUFFRCxPQUFPO1FBQ1ZJLENBQUMsRUFBRVgsU0FBUyxDQUFDVyxDQUFDLEdBQUdWLFFBQVEsQ0FBQ1c7TUFDNUIs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TUFBTTVNLFFBQVEsQ0FBQ21ELGFBQWEsQ0FBQ2hDLFFBQVEsQ0FBQ3JDLFFBQVEsQ0FBQztNQUN0RSxJQUFJUSxLQUFLLEtBQUtzTixjQUFjLENBQUN0TixLQUFLLElBQUlHLE1BQU0sS0FBS21OLGNBQWMsQ0FBQ25OLE1BQU0sRUFBRTtRQUN0RSxPQUFPO1VBQ0x3QixLQUFLLEVBQUU7WUFDTFosS0FBSyxFQUFFO1VBQ1Q7UUFDRixDQUFDO01BQ0g7TUFDQSxPQUFPLENBQUMsQ0FBQztJQUNYO0VBQ0YsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3Mtc3lzdGVtLy4vbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9jb3JlL2Rpc3QvZmxvYXRpbmctdWkuY29yZS5tanM/NTZiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRTaWRlQXhpcywgZ2V0QWxpZ25tZW50QXhpcywgZ2V0QXhpc0xlbmd0aCwgZ2V0U2lkZSwgZ2V0QWxpZ25tZW50LCBldmFsdWF0ZSwgZ2V0UGFkZGluZ09iamVjdCwgcmVjdFRvQ2xpZW50UmVjdCwgbWluLCBjbGFtcCwgcGxhY2VtZW50cywgZ2V0QWxpZ25tZW50U2lkZXMsIGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50LCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBzaWRlcywgbWF4LCBnZXRPcHBvc2l0ZUF4aXMgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuZXhwb3J0IHsgcmVjdFRvQ2xpZW50UmVjdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscyc7XG5cbmZ1bmN0aW9uIGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KF9yZWYsIHBsYWNlbWVudCwgcnRsKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gPSBfcmVmO1xuICBjb25zdCBzaWRlQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWdubWVudEF4aXMgPSBnZXRBbGlnbm1lbnRBeGlzKHBsYWNlbWVudCk7XG4gIGNvbnN0IGFsaWduTGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9IHNpZGVBeGlzID09PSAneSc7XG4gIGNvbnN0IGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBmbG9hdGluZy53aWR0aCAvIDI7XG4gIGNvbnN0IGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZmxvYXRpbmcuaGVpZ2h0IC8gMjtcbiAgY29uc3QgY29tbW9uQWxpZ24gPSByZWZlcmVuY2VbYWxpZ25MZW5ndGhdIC8gMiAtIGZsb2F0aW5nW2FsaWduTGVuZ3RoXSAvIDI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZmxvYXRpbmcuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCAtIGZsb2F0aW5nLndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkpIHtcbiAgICBjYXNlICdzdGFydCc6XG4gICAgICBjb29yZHNbYWxpZ25tZW50QXhpc10gLT0gY29tbW9uQWxpZ24gKiAocnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5kJzpcbiAgICAgIGNvb3Jkc1thbGlnbm1lbnRBeGlzXSArPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gY29vcmRzO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqXG4gKiBUaGlzIGV4cG9ydCBkb2VzIG5vdCBoYXZlIGFueSBgcGxhdGZvcm1gIGludGVyZmFjZSBsb2dpYy4gWW91IHdpbGwgbmVlZCB0b1xuICogd3JpdGUgb25lIGZvciB0aGUgcGxhdGZvcm0geW91IGFyZSB1c2luZyBGbG9hdGluZyBVSSB3aXRoLlxuICovXG5jb25zdCBjb21wdXRlUG9zaXRpb24gPSBhc3luYyAocmVmZXJlbmNlLCBmbG9hdGluZywgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IHZhbGlkTWlkZGxld2FyZSA9IG1pZGRsZXdhcmUuZmlsdGVyKEJvb2xlYW4pO1xuICBjb25zdCBydGwgPSBhd2FpdCAocGxhdGZvcm0uaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmlzUlRMKGZsb2F0aW5nKSk7XG4gIGxldCByZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIHN0cmF0ZWd5XG4gIH0pO1xuICBsZXQge1xuICAgIHgsXG4gICAgeVxuICB9ID0gY29tcHV0ZUNvb3Jkc0Zyb21QbGFjZW1lbnQocmVjdHMsIHBsYWNlbWVudCwgcnRsKTtcbiAgbGV0IHN0YXRlZnVsUGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICBsZXQgbWlkZGxld2FyZURhdGEgPSB7fTtcbiAgbGV0IHJlc2V0Q291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbGlkTWlkZGxld2FyZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICBmblxuICAgIH0gPSB2YWxpZE1pZGRsZXdhcmVbaV07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSBhd2FpdCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4ID0gbmV4dFggIT0gbnVsbCA/IG5leHRYIDogeDtcbiAgICB5ID0gbmV4dFkgIT0gbnVsbCA/IG5leHRZIDogeTtcbiAgICBtaWRkbGV3YXJlRGF0YSA9IHtcbiAgICAgIC4uLm1pZGRsZXdhcmVEYXRhLFxuICAgICAgW25hbWVdOiB7XG4gICAgICAgIC4uLm1pZGRsZXdhcmVEYXRhW25hbWVdLFxuICAgICAgICAuLi5kYXRhXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAocmVzZXQgJiYgcmVzZXRDb3VudCA8PSA1MCkge1xuICAgICAgcmVzZXRDb3VudCsrO1xuICAgICAgaWYgKHR5cGVvZiByZXNldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyBhd2FpdCBwbGF0Zm9ybS5nZXRFbGVtZW50UmVjdHMoe1xuICAgICAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgICAgICBzdHJhdGVneVxuICAgICAgICAgIH0pIDogcmVzZXQucmVjdHM7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSA9IGNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50KHJlY3RzLCBzdGF0ZWZ1bFBsYWNlbWVudCwgcnRsKSk7XG4gICAgICB9XG4gICAgICBpID0gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgeCxcbiAgICB5LFxuICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgc3RyYXRlZ3ksXG4gICAgbWlkZGxld2FyZURhdGFcbiAgfTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3Qgb2Ygb3ZlcmZsb3cgc2lkZSBvZmZzZXRzIHRoYXQgZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZVxuICogZWxlbWVudCBpcyBvdmVyZmxvd2luZyBhIGdpdmVuIGNsaXBwaW5nIGJvdW5kYXJ5IG9uIGVhY2ggc2lkZS5cbiAqIC0gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgYm91bmRhcnkgYnkgdGhhdCBudW1iZXIgb2YgcGl4ZWxzXG4gKiAtIG5lZ2F0aXZlID0gaG93IG1hbnkgcGl4ZWxzIGxlZnQgYmVmb3JlIGl0IHdpbGwgb3ZlcmZsb3dcbiAqIC0gMCA9IGxpZXMgZmx1c2ggd2l0aCB0aGUgYm91bmRhcnlcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9kZXRlY3RPdmVyZmxvd1xuICovXG5hc3luYyBmdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICB2YXIgX2F3YWl0JHBsYXRmb3JtJGlzRWxlO1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgcGxhdGZvcm0sXG4gICAgcmVjdHMsXG4gICAgZWxlbWVudHMsXG4gICAgc3RyYXRlZ3lcbiAgfSA9IHN0YXRlO1xuICBjb25zdCB7XG4gICAgYm91bmRhcnkgPSAnY2xpcHBpbmdBbmNlc3RvcnMnLFxuICAgIHJvb3RCb3VuZGFyeSA9ICd2aWV3cG9ydCcsXG4gICAgZWxlbWVudENvbnRleHQgPSAnZmxvYXRpbmcnLFxuICAgIGFsdEJvdW5kYXJ5ID0gZmFsc2UsXG4gICAgcGFkZGluZyA9IDBcbiAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgY29uc3QgcGFkZGluZ09iamVjdCA9IGdldFBhZGRpbmdPYmplY3QocGFkZGluZyk7XG4gIGNvbnN0IGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gJ2Zsb2F0aW5nJyA/ICdyZWZlcmVuY2UnIDogJ2Zsb2F0aW5nJztcbiAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgY29uc3QgY2xpcHBpbmdDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChhd2FpdCBwbGF0Zm9ybS5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6ICgoX2F3YWl0JHBsYXRmb3JtJGlzRWxlID0gYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGVsZW1lbnQpKSkgIT0gbnVsbCA/IF9hd2FpdCRwbGF0Zm9ybSRpc0VsZSA6IHRydWUpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgKGF3YWl0IChwbGF0Zm9ybS5nZXREb2N1bWVudEVsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldERvY3VtZW50RWxlbWVudChlbGVtZW50cy5mbG9hdGluZykpKSxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSkpO1xuICBjb25zdCByZWN0ID0gZWxlbWVudENvbnRleHQgPT09ICdmbG9hdGluZycgPyB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoOiByZWN0cy5mbG9hdGluZy53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3RzLmZsb2F0aW5nLmhlaWdodFxuICB9IDogcmVjdHMucmVmZXJlbmNlO1xuICBjb25zdCBvZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgb2Zmc2V0U2NhbGUgPSAoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KG9mZnNldFBhcmVudCkpKSA/IChhd2FpdCAocGxhdGZvcm0uZ2V0U2NhbGUgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldFNjYWxlKG9mZnNldFBhcmVudCkpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH07XG4gIGNvbnN0IGVsZW1lbnRDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChwbGF0Zm9ybS5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCA/IGF3YWl0IHBsYXRmb3JtLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0KHtcbiAgICBlbGVtZW50cyxcbiAgICByZWN0LFxuICAgIG9mZnNldFBhcmVudCxcbiAgICBzdHJhdGVneVxuICB9KSA6IHJlY3QpO1xuICByZXR1cm4ge1xuICAgIHRvcDogKGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGJvdHRvbTogKGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgLyBvZmZzZXRTY2FsZS55LFxuICAgIGxlZnQ6IChjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQpIC8gb2Zmc2V0U2NhbGUueCxcbiAgICByaWdodDogKGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCkgLyBvZmZzZXRTY2FsZS54XG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93ID0gb3B0aW9ucyA9PiAoe1xuICBuYW1lOiAnYXJyb3cnLFxuICBvcHRpb25zLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGxhY2VtZW50LFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybSxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgbWlkZGxld2FyZURhdGFcbiAgICB9ID0gc3RhdGU7XG4gICAgLy8gU2luY2UgYGVsZW1lbnRgIGlzIHJlcXVpcmVkLCB3ZSBkb24ndCBQYXJ0aWFsPD4gdGhlIHR5cGUuXG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudCxcbiAgICAgIHBhZGRpbmcgPSAwXG4gICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKSB8fCB7fTtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgICBjb25zdCBheGlzID0gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEF4aXNMZW5ndGgoYXhpcyk7XG4gICAgY29uc3QgYXJyb3dEaW1lbnNpb25zID0gYXdhaXQgcGxhdGZvcm0uZ2V0RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICBjb25zdCBpc1lBeGlzID0gYXhpcyA9PT0gJ3knO1xuICAgIGNvbnN0IG1pblByb3AgPSBpc1lBeGlzID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgY29uc3QgbWF4UHJvcCA9IGlzWUF4aXMgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgY29uc3QgY2xpZW50UHJvcCA9IGlzWUF4aXMgPyAnY2xpZW50SGVpZ2h0JyA6ICdjbGllbnRXaWR0aCc7XG4gICAgY29uc3QgZW5kRGlmZiA9IHJlY3RzLnJlZmVyZW5jZVtsZW5ndGhdICsgcmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gY29vcmRzW2F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICBjb25zdCBzdGFydERpZmYgPSBjb29yZHNbYXhpc10gLSByZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gICAgY29uc3QgYXJyb3dPZmZzZXRQYXJlbnQgPSBhd2FpdCAocGxhdGZvcm0uZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5nZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkpO1xuICAgIGxldCBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBhcnJvd09mZnNldFBhcmVudFtjbGllbnRQcm9wXSA6IDA7XG5cbiAgICAvLyBET00gcGxhdGZvcm0gY2FuIHJldHVybiBgd2luZG93YCBhcyB0aGUgYG9mZnNldFBhcmVudGAuXG4gICAgaWYgKCFjbGllbnRTaXplIHx8ICEoYXdhaXQgKHBsYXRmb3JtLmlzRWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNFbGVtZW50KGFycm93T2Zmc2V0UGFyZW50KSkpKSB7XG4gICAgICBjbGllbnRTaXplID0gZWxlbWVudHMuZmxvYXRpbmdbY2xpZW50UHJvcF0gfHwgcmVjdHMuZmxvYXRpbmdbbGVuZ3RoXTtcbiAgICB9XG4gICAgY29uc3QgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7XG5cbiAgICAvLyBJZiB0aGUgcGFkZGluZyBpcyBsYXJnZSBlbm91Z2ggdGhhdCBpdCBjYXVzZXMgdGhlIGFycm93IHRvIG5vIGxvbmdlciBiZVxuICAgIC8vIGNlbnRlcmVkLCBtb2RpZnkgdGhlIHBhZGRpbmcgc28gdGhhdCBpdCBpcyBjZW50ZXJlZC5cbiAgICBjb25zdCBsYXJnZXN0UG9zc2libGVQYWRkaW5nID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd0RpbWVuc2lvbnNbbGVuZ3RoXSAvIDIgLSAxO1xuICAgIGNvbnN0IG1pblBhZGRpbmcgPSBtaW4ocGFkZGluZ09iamVjdFttaW5Qcm9wXSwgbGFyZ2VzdFBvc3NpYmxlUGFkZGluZyk7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IG1pbihwYWRkaW5nT2JqZWN0W21heFByb3BdLCBsYXJnZXN0UG9zc2libGVQYWRkaW5nKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpZiB0aGUgY2VudGVyXG4gICAgLy8gcG9pbnQgaXMgb3V0c2lkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCdzIGJvdW5kcy5cbiAgICBjb25zdCBtaW4kMSA9IG1pblBhZGRpbmc7XG4gICAgY29uc3QgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC0gbWF4UGFkZGluZztcbiAgICBjb25zdCBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93RGltZW5zaW9uc1tsZW5ndGhdIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIGNvbnN0IG9mZnNldCA9IGNsYW1wKG1pbiQxLCBjZW50ZXIsIG1heCk7XG5cbiAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsIGVub3VnaCB0aGF0IHRoZSBhcnJvdydzIHBhZGRpbmcgY2F1c2VzIGl0IHRvXG4gICAgLy8gdG8gcG9pbnQgdG8gbm90aGluZyBmb3IgYW4gYWxpZ25lZCBwbGFjZW1lbnQsIGFkanVzdCB0aGUgb2Zmc2V0IG9mIHRoZVxuICAgIC8vIGZsb2F0aW5nIGVsZW1lbnQgaXRzZWxmLiBUbyBlbnN1cmUgYHNoaWZ0KClgIGNvbnRpbnVlcyB0byB0YWtlIGFjdGlvbixcbiAgICAvLyBhIHNpbmdsZSByZXNldCBpcyBwZXJmb3JtZWQgd2hlbiB0aGlzIGlzIHRydWUuXG4gICAgY29uc3Qgc2hvdWxkQWRkT2Zmc2V0ID0gIW1pZGRsZXdhcmVEYXRhLmFycm93ICYmIGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9IG51bGwgJiYgY2VudGVyICE9PSBvZmZzZXQgJiYgcmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gKGNlbnRlciA8IG1pbiQxID8gbWluUGFkZGluZyA6IG1heFBhZGRpbmcpIC0gYXJyb3dEaW1lbnNpb25zW2xlbmd0aF0gLyAyIDwgMDtcbiAgICBjb25zdCBhbGlnbm1lbnRPZmZzZXQgPSBzaG91bGRBZGRPZmZzZXQgPyBjZW50ZXIgPCBtaW4kMSA/IGNlbnRlciAtIG1pbiQxIDogY2VudGVyIC0gbWF4IDogMDtcbiAgICByZXR1cm4ge1xuICAgICAgW2F4aXNdOiBjb29yZHNbYXhpc10gKyBhbGlnbm1lbnRPZmZzZXQsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIFtheGlzXTogb2Zmc2V0LFxuICAgICAgICBjZW50ZXJPZmZzZXQ6IGNlbnRlciAtIG9mZnNldCAtIGFsaWdubWVudE9mZnNldCxcbiAgICAgICAgLi4uKHNob3VsZEFkZE9mZnNldCAmJiB7XG4gICAgICAgICAgYWxpZ25tZW50T2Zmc2V0XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgcmVzZXQ6IHNob3VsZEFkZE9mZnNldFxuICAgIH07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRQbGFjZW1lbnRMaXN0KGFsaWdubWVudCwgYXV0b0FsaWdubWVudCwgYWxsb3dlZFBsYWNlbWVudHMpIHtcbiAgY29uc3QgYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCA9IGFsaWdubWVudCA/IFsuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpID09PSBhbGlnbm1lbnQpLCAuLi5hbGxvd2VkUGxhY2VtZW50cy5maWx0ZXIocGxhY2VtZW50ID0+IGdldEFsaWdubWVudChwbGFjZW1lbnQpICE9PSBhbGlnbm1lbnQpXSA6IGFsbG93ZWRQbGFjZW1lbnRzLmZpbHRlcihwbGFjZW1lbnQgPT4gZ2V0U2lkZShwbGFjZW1lbnQpID09PSBwbGFjZW1lbnQpO1xuICByZXR1cm4gYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudC5maWx0ZXIocGxhY2VtZW50ID0+IHtcbiAgICBpZiAoYWxpZ25tZW50KSB7XG4gICAgICByZXR1cm4gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkgPT09IGFsaWdubWVudCB8fCAoYXV0b0FsaWdubWVudCA/IGdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCkgIT09IHBsYWNlbWVudCA6IGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0pO1xufVxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ2F1dG9QbGFjZW1lbnQnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkYXV0b1AsIF9taWRkbGV3YXJlRGF0YSRhdXRvUDIsIF9wbGFjZW1lbnRzVGhhdEZpdE9uRTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgYWxpZ25tZW50LFxuICAgICAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMsXG4gICAgICAgIGF1dG9BbGlnbm1lbnQgPSB0cnVlLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzJDEgPSBhbGlnbm1lbnQgIT09IHVuZGVmaW5lZCB8fCBhbGxvd2VkUGxhY2VtZW50cyA9PT0gcGxhY2VtZW50cyA/IGdldFBsYWNlbWVudExpc3QoYWxpZ25tZW50IHx8IG51bGwsIGF1dG9BbGlnbm1lbnQsIGFsbG93ZWRQbGFjZW1lbnRzKSA6IGFsbG93ZWRQbGFjZW1lbnRzO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9ICgoX21pZGRsZXdhcmVEYXRhJGF1dG9QID0gbWlkZGxld2FyZURhdGEuYXV0b1BsYWNlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRhdXRvUC5pbmRleCkgfHwgMDtcbiAgICAgIGNvbnN0IGN1cnJlbnRQbGFjZW1lbnQgPSBwbGFjZW1lbnRzJDFbY3VycmVudEluZGV4XTtcbiAgICAgIGlmIChjdXJyZW50UGxhY2VtZW50ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYWxpZ25tZW50U2lkZXMgPSBnZXRBbGlnbm1lbnRTaWRlcyhjdXJyZW50UGxhY2VtZW50LCByZWN0cywgYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpKTtcblxuICAgICAgLy8gTWFrZSBgY29tcHV0ZUNvb3Jkc2Agc3RhcnQgZnJvbSB0aGUgcmlnaHQgcGxhY2UuXG4gICAgICBpZiAocGxhY2VtZW50ICE9PSBjdXJyZW50UGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50cyQxWzBdXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudE92ZXJmbG93cyA9IFtvdmVyZmxvd1tnZXRTaWRlKGN1cnJlbnRQbGFjZW1lbnQpXSwgb3ZlcmZsb3dbYWxpZ25tZW50U2lkZXNbMF1dLCBvdmVyZmxvd1thbGlnbm1lbnRTaWRlc1sxXV1dO1xuICAgICAgY29uc3QgYWxsT3ZlcmZsb3dzID0gWy4uLigoKF9taWRkbGV3YXJlRGF0YSRhdXRvUDIgPSBtaWRkbGV3YXJlRGF0YS5hdXRvUGxhY2VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGF1dG9QMi5vdmVyZmxvd3MpIHx8IFtdKSwge1xuICAgICAgICBwbGFjZW1lbnQ6IGN1cnJlbnRQbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93czogY3VycmVudE92ZXJmbG93c1xuICAgICAgfV07XG4gICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50cyQxW2N1cnJlbnRJbmRleCArIDFdO1xuXG4gICAgICAvLyBUaGVyZSBhcmUgbW9yZSBwbGFjZW1lbnRzIHRvIGNoZWNrLlxuICAgICAgaWYgKG5leHRQbGFjZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBpbmRleDogY3VycmVudEluZGV4ICsgMSxcbiAgICAgICAgICAgIG92ZXJmbG93czogYWxsT3ZlcmZsb3dzXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcGxhY2VtZW50OiBuZXh0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlID0gYWxsT3ZlcmZsb3dzLm1hcChkID0+IHtcbiAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KGQucGxhY2VtZW50KTtcbiAgICAgICAgcmV0dXJuIFtkLnBsYWNlbWVudCwgYWxpZ25tZW50ICYmIGNyb3NzQXhpcyA/XG4gICAgICAgIC8vIENoZWNrIGFsb25nIHRoZSBtYWluQXhpcyBhbmQgbWFpbiBjcm9zc0F4aXMgc2lkZS5cbiAgICAgICAgZC5vdmVyZmxvd3Muc2xpY2UoMCwgMikucmVkdWNlKChhY2MsIHYpID0+IGFjYyArIHYsIDApIDpcbiAgICAgICAgLy8gQ2hlY2sgb25seSB0aGUgbWFpbkF4aXMuXG4gICAgICAgIGQub3ZlcmZsb3dzWzBdLCBkLm92ZXJmbG93c107XG4gICAgICB9KS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSk7XG4gICAgICBjb25zdCBwbGFjZW1lbnRzVGhhdEZpdE9uRWFjaFNpZGUgPSBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2UuZmlsdGVyKGQgPT4gZFsyXS5zbGljZSgwLFxuICAgICAgLy8gQWxpZ25lZCBwbGFjZW1lbnRzIHNob3VsZCBub3QgY2hlY2sgdGhlaXIgb3Bwb3NpdGUgY3Jvc3NBeGlzXG4gICAgICAvLyBzaWRlLlxuICAgICAgZ2V0QWxpZ25tZW50KGRbMF0pID8gMiA6IDMpLmV2ZXJ5KHYgPT4gdiA8PSAwKSk7XG4gICAgICBjb25zdCByZXNldFBsYWNlbWVudCA9ICgoX3BsYWNlbWVudHNUaGF0Rml0T25FID0gcGxhY2VtZW50c1RoYXRGaXRPbkVhY2hTaWRlWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3BsYWNlbWVudHNUaGF0Rml0T25FWzBdKSB8fCBwbGFjZW1lbnRzU29ydGVkQnlNb3N0U3BhY2VbMF1bMF07XG4gICAgICBpZiAocmVzZXRQbGFjZW1lbnQgIT09IHBsYWNlbWVudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGluZGV4OiBjdXJyZW50SW5kZXggKyAxLFxuICAgICAgICAgICAgb3ZlcmZsb3dzOiBhbGxPdmVyZmxvd3NcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IHJlc2V0UGxhY2VtZW50XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX21pZGRsZXdhcmVEYXRhJGFycm93LCBfbWlkZGxld2FyZURhdGEkZmxpcDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBtaWRkbGV3YXJlRGF0YSxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIGluaXRpYWxQbGFjZW1lbnQsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBlbGVtZW50c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSB0cnVlLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgZmFsbGJhY2tTdHJhdGVneSA9ICdiZXN0Rml0JyxcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiA9ICdub25lJyxcbiAgICAgICAgZmxpcEFsaWdubWVudCA9IHRydWUsXG4gICAgICAgIC4uLmRldGVjdE92ZXJmbG93T3B0aW9uc1xuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcblxuICAgICAgLy8gSWYgYSByZXNldCBieSB0aGUgYXJyb3cgd2FzIGNhdXNlZCBkdWUgdG8gYW4gYWxpZ25tZW50IG9mZnNldCBiZWluZ1xuICAgICAgLy8gYWRkZWQsIHdlIHNob3VsZCBza2lwIGFueSBsb2dpYyBub3cgc2luY2UgYGZsaXAoKWAgaGFzIGFscmVhZHkgZG9uZSBpdHNcbiAgICAgIC8vIHdvcmsuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI1NDkjaXNzdWVjb21tZW50LTE3MTk2MDE2NDNcbiAgICAgIGlmICgoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBjb25zdCBzaWRlID0gZ2V0U2lkZShwbGFjZW1lbnQpO1xuICAgICAgY29uc3QgaW5pdGlhbFNpZGVBeGlzID0gZ2V0U2lkZUF4aXMoaW5pdGlhbFBsYWNlbWVudCk7XG4gICAgICBjb25zdCBpc0Jhc2VQbGFjZW1lbnQgPSBnZXRTaWRlKGluaXRpYWxQbGFjZW1lbnQpID09PSBpbml0aWFsUGxhY2VtZW50O1xuICAgICAgY29uc3QgcnRsID0gYXdhaXQgKHBsYXRmb3JtLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybS5pc1JUTChlbGVtZW50cy5mbG9hdGluZykpO1xuICAgICAgY29uc3QgZmFsbGJhY2tQbGFjZW1lbnRzID0gc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIHx8IChpc0Jhc2VQbGFjZW1lbnQgfHwgIWZsaXBBbGlnbm1lbnQgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoaW5pdGlhbFBsYWNlbWVudCldIDogZ2V0RXhwYW5kZWRQbGFjZW1lbnRzKGluaXRpYWxQbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IGhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24gPSBmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uICE9PSAnbm9uZSc7XG4gICAgICBpZiAoIXNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyAmJiBoYXNGYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uKSB7XG4gICAgICAgIGZhbGxiYWNrUGxhY2VtZW50cy5wdXNoKC4uLmdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMoaW5pdGlhbFBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbiwgcnRsKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFjZW1lbnRzID0gW2luaXRpYWxQbGFjZW1lbnQsIC4uLmZhbGxiYWNrUGxhY2VtZW50c107XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3dzID0gW107XG4gICAgICBsZXQgb3ZlcmZsb3dzRGF0YSA9ICgoX21pZGRsZXdhcmVEYXRhJGZsaXAgPSBtaWRkbGV3YXJlRGF0YS5mbGlwKSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJGZsaXAub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVdKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBzaWRlcyA9IGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCk7XG4gICAgICAgIG92ZXJmbG93cy5wdXNoKG92ZXJmbG93W3NpZGVzWzBdXSwgb3ZlcmZsb3dbc2lkZXNbMV1dKTtcbiAgICAgIH1cbiAgICAgIG92ZXJmbG93c0RhdGEgPSBbLi4ub3ZlcmZsb3dzRGF0YSwge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG92ZXJmbG93c1xuICAgICAgfV07XG5cbiAgICAgIC8vIE9uZSBvciBtb3JlIHNpZGVzIGlzIG92ZXJmbG93aW5nLlxuICAgICAgaWYgKCFvdmVyZmxvd3MuZXZlcnkoc2lkZSA9PiBzaWRlIDw9IDApKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkZmxpcDIsIF9vdmVyZmxvd3NEYXRhJGZpbHRlcjtcbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gKCgoX21pZGRsZXdhcmVEYXRhJGZsaXAyID0gbWlkZGxld2FyZURhdGEuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRmbGlwMi5pbmRleCkgfHwgMCkgKyAxO1xuICAgICAgICBjb25zdCBuZXh0UGxhY2VtZW50ID0gcGxhY2VtZW50c1tuZXh0SW5kZXhdO1xuICAgICAgICBpZiAobmV4dFBsYWNlbWVudCkge1xuICAgICAgICAgIGNvbnN0IGlnbm9yZUNyb3NzQXhpc092ZXJmbG93ID0gY2hlY2tDcm9zc0F4aXMgPT09ICdhbGlnbm1lbnQnID8gaW5pdGlhbFNpZGVBeGlzICE9PSBnZXRTaWRlQXhpcyhuZXh0UGxhY2VtZW50KSA6IGZhbHNlO1xuICAgICAgICAgIGlmICghaWdub3JlQ3Jvc3NBeGlzT3ZlcmZsb3cgfHxcbiAgICAgICAgICAvLyBXZSBsZWF2ZSB0aGUgY3VycmVudCBtYWluIGF4aXMgb25seSBpZiBldmVyeSBwbGFjZW1lbnQgb24gdGhhdCBheGlzXG4gICAgICAgICAgLy8gb3ZlcmZsb3dzIHRoZSBtYWluIGF4aXMuXG4gICAgICAgICAgb3ZlcmZsb3dzRGF0YS5ldmVyeShkID0+IGdldFNpZGVBeGlzKGQucGxhY2VtZW50KSA9PT0gaW5pdGlhbFNpZGVBeGlzID8gZC5vdmVyZmxvd3NbMF0gPiAwIDogdHJ1ZSkpIHtcbiAgICAgICAgICAgIC8vIFRyeSBuZXh0IHBsYWNlbWVudCBhbmQgcmUtcnVuIHRoZSBsaWZlY3ljbGUuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd3M6IG92ZXJmbG93c0RhdGFcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6IG5leHRQbGFjZW1lbnRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCwgZmluZCB0aGUgY2FuZGlkYXRlcyB0aGF0IGZpdCBvbiB0aGUgbWFpbkF4aXMgc2lkZSBvZiBvdmVyZmxvdyxcbiAgICAgICAgLy8gdGhlbiBmaW5kIHRoZSBwbGFjZW1lbnQgdGhhdCBmaXRzIHRoZSBiZXN0IG9uIHRoZSBtYWluIGNyb3NzQXhpcyBzaWRlLlxuICAgICAgICBsZXQgcmVzZXRQbGFjZW1lbnQgPSAoX292ZXJmbG93c0RhdGEkZmlsdGVyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiBkLm92ZXJmbG93c1swXSA8PSAwKS5zb3J0KChhLCBiKSA9PiBhLm92ZXJmbG93c1sxXSAtIGIub3ZlcmZsb3dzWzFdKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9vdmVyZmxvd3NEYXRhJGZpbHRlci5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZhbGxiYWNrLlxuICAgICAgICBpZiAoIXJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgc3dpdGNoIChmYWxsYmFja1N0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdiZXN0Rml0JzpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlbWVudCA9IChfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyID0gb3ZlcmZsb3dzRGF0YS5maWx0ZXIoZCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGFzRmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2lkZUF4aXMgPSBnZXRTaWRlQXhpcyhkLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2lkZUF4aXMgPT09IGluaXRpYWxTaWRlQXhpcyB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBiaWFzIHRvIHRoZSBgeWAgc2lkZSBheGlzIGR1ZSB0byBob3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRpbmcgZGlyZWN0aW9ucyBmYXZvcmluZyBncmVhdGVyIHdpZHRoLlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2lkZUF4aXMgPT09ICd5JztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pLm1hcChkID0+IFtkLnBsYWNlbWVudCwgZC5vdmVyZmxvd3MuZmlsdGVyKG92ZXJmbG93ID0+IG92ZXJmbG93ID4gMCkucmVkdWNlKChhY2MsIG92ZXJmbG93KSA9PiBhY2MgKyBvdmVyZmxvdywgMCldKS5zb3J0KChhLCBiKSA9PiBhWzFdIC0gYlsxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfb3ZlcmZsb3dzRGF0YSRmaWx0ZXIyWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gcGxhY2VtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbFBsYWNlbWVudCc6XG4gICAgICAgICAgICAgIHJlc2V0UGxhY2VtZW50ID0gaW5pdGlhbFBsYWNlbWVudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHJlc2V0UGxhY2VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogcmVzZXRQbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aFxuICB9O1xufVxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBzaWRlcy5zb21lKHNpZGUgPT4gb3ZlcmZsb3dbc2lkZV0gPj0gMCk7XG59XG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gaGlkZSB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbiBhcHBsaWNhYmxlIHNpdHVhdGlvbnMsIHN1Y2ggYXNcbiAqIHdoZW4gaXQgaXMgbm90IGluIHRoZSBzYW1lIGNsaXBwaW5nIGNvbnRleHQgYXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2hpZGVcbiAqL1xuY29uc3QgaGlkZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnaGlkZScsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWN0c1xuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzdHJhdGVneSA9ICdyZWZlcmVuY2VIaWRkZW4nLFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgJ3JlZmVyZW5jZUhpZGRlbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3RzLnJlZmVyZW5jZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlSGlkZGVuT2Zmc2V0czogb2Zmc2V0cyxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VIaWRkZW46IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZXNjYXBlZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICAgICAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdHMuZmxvYXRpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGVzY2FwZWRPZmZzZXRzOiBvZmZzZXRzLFxuICAgICAgICAgICAgICAgIGVzY2FwZWQ6IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvZmZzZXRzKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdChyZWN0cykge1xuICBjb25zdCBtaW5YID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QubGVmdCkpO1xuICBjb25zdCBtaW5ZID0gbWluKC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QudG9wKSk7XG4gIGNvbnN0IG1heFggPSBtYXgoLi4ucmVjdHMubWFwKHJlY3QgPT4gcmVjdC5yaWdodCkpO1xuICBjb25zdCBtYXhZID0gbWF4KC4uLnJlY3RzLm1hcChyZWN0ID0+IHJlY3QuYm90dG9tKSk7XG4gIHJldHVybiB7XG4gICAgeDogbWluWCxcbiAgICB5OiBtaW5ZLFxuICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRSZWN0c0J5TGluZShyZWN0cykge1xuICBjb25zdCBzb3J0ZWRSZWN0cyA9IHJlY3RzLnNsaWNlKCkuc29ydCgoYSwgYikgPT4gYS55IC0gYi55KTtcbiAgY29uc3QgZ3JvdXBzID0gW107XG4gIGxldCBwcmV2UmVjdCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkUmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCByZWN0ID0gc29ydGVkUmVjdHNbaV07XG4gICAgaWYgKCFwcmV2UmVjdCB8fCByZWN0LnkgLSBwcmV2UmVjdC55ID4gcHJldlJlY3QuaGVpZ2h0IC8gMikge1xuICAgICAgZ3JvdXBzLnB1c2goW3JlY3RdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBzW2dyb3Vwcy5sZW5ndGggLSAxXS5wdXNoKHJlY3QpO1xuICAgIH1cbiAgICBwcmV2UmVjdCA9IHJlY3Q7XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcy5tYXAocmVjdCA9PiByZWN0VG9DbGllbnRSZWN0KGdldEJvdW5kaW5nUmVjdChyZWN0KSkpO1xufVxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdpbmxpbmUnLFxuICAgIG9wdGlvbnMsXG4gICAgYXN5bmMgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICBlbGVtZW50cyxcbiAgICAgICAgcmVjdHMsXG4gICAgICAgIHBsYXRmb3JtLFxuICAgICAgICBzdHJhdGVneVxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgLy8gQSBNb3VzZUV2ZW50J3MgY2xpZW50e1gsWX0gY29vcmRzIGNhbiBiZSB1cCB0byAyIHBpeGVscyBvZmYgYVxuICAgICAgLy8gQ2xpZW50UmVjdCdzIGJvdW5kcywgZGVzcGl0ZSB0aGUgZXZlbnQgbGlzdGVuZXIgYmVpbmcgdHJpZ2dlcmVkLiBBXG4gICAgICAvLyBwYWRkaW5nIG9mIDIgc2VlbXMgdG8gaGFuZGxlIHRoaXMgaXNzdWUuXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhZGRpbmcgPSAyLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3QgbmF0aXZlQ2xpZW50UmVjdHMgPSBBcnJheS5mcm9tKChhd2FpdCAocGxhdGZvcm0uZ2V0Q2xpZW50UmVjdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXRmb3JtLmdldENsaWVudFJlY3RzKGVsZW1lbnRzLnJlZmVyZW5jZSkpKSB8fCBbXSk7XG4gICAgICBjb25zdCBjbGllbnRSZWN0cyA9IGdldFJlY3RzQnlMaW5lKG5hdGl2ZUNsaWVudFJlY3RzKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrID0gcmVjdFRvQ2xpZW50UmVjdChnZXRCb3VuZGluZ1JlY3QobmF0aXZlQ2xpZW50UmVjdHMpKTtcbiAgICAgIGNvbnN0IHBhZGRpbmdPYmplY3QgPSBnZXRQYWRkaW5nT2JqZWN0KHBhZGRpbmcpO1xuICAgICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWQuXG4gICAgICAgIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0ICYmIHggIT0gbnVsbCAmJiB5ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCByZWN0IGluIHdoaWNoIHRoZSBwb2ludCBpcyBmdWxseSBpbnNpZGUuXG4gICAgICAgICAgcmV0dXJuIGNsaWVudFJlY3RzLmZpbmQocmVjdCA9PiB4ID4gcmVjdC5sZWZ0IC0gcGFkZGluZ09iamVjdC5sZWZ0ICYmIHggPCByZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodCAmJiB5ID4gcmVjdC50b3AgLSBwYWRkaW5nT2JqZWN0LnRvcCAmJiB5IDwgcmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSkgfHwgZmFsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBhcmUgMiBvciBtb3JlIGNvbm5lY3RlZCByZWN0cy5cbiAgICAgICAgaWYgKGNsaWVudFJlY3RzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgaWYgKGdldFNpZGVBeGlzKHBsYWNlbWVudCkgPT09ICd5Jykge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RSZWN0ID0gY2xpZW50UmVjdHNbMF07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVjdCA9IGNsaWVudFJlY3RzW2NsaWVudFJlY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY29uc3QgaXNUb3AgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICd0b3AnO1xuICAgICAgICAgICAgY29uc3QgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICBib3R0b20sXG4gICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICB4OiBsZWZ0LFxuICAgICAgICAgICAgICB5OiB0b3BcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlzTGVmdFNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCkgPT09ICdsZWZ0JztcbiAgICAgICAgICBjb25zdCBtYXhSaWdodCA9IG1heCguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LnJpZ2h0KSk7XG4gICAgICAgICAgY29uc3QgbWluTGVmdCA9IG1pbiguLi5jbGllbnRSZWN0cy5tYXAocmVjdCA9PiByZWN0LmxlZnQpKTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIocmVjdCA9PiBpc0xlZnRTaWRlID8gcmVjdC5sZWZ0ID09PSBtaW5MZWZ0IDogcmVjdC5yaWdodCA9PT0gbWF4UmlnaHQpO1xuICAgICAgICAgIGNvbnN0IHRvcCA9IG1lYXN1cmVSZWN0c1swXS50b3A7XG4gICAgICAgICAgY29uc3QgYm90dG9tID0gbWVhc3VyZVJlY3RzW21lYXN1cmVSZWN0cy5sZW5ndGggLSAxXS5ib3R0b207XG4gICAgICAgICAgY29uc3QgbGVmdCA9IG1pbkxlZnQ7XG4gICAgICAgICAgY29uc3QgcmlnaHQgPSBtYXhSaWdodDtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIGJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgeDogbGVmdCxcbiAgICAgICAgICAgIHk6IHRvcFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzZXRSZWN0cyA9IGF3YWl0IHBsYXRmb3JtLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICAgIHJlZmVyZW5jZToge1xuICAgICAgICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAgICB9LFxuICAgICAgICBmbG9hdGluZzogZWxlbWVudHMuZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWN0cy5yZWZlcmVuY2UueCAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueCB8fCByZWN0cy5yZWZlcmVuY2UueSAhPT0gcmVzZXRSZWN0cy5yZWZlcmVuY2UueSB8fCByZWN0cy5yZWZlcmVuY2Uud2lkdGggIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLndpZHRoIHx8IHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgIT09IHJlc2V0UmVjdHMucmVmZXJlbmNlLmhlaWdodCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICByZWN0czogcmVzZXRSZWN0c1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBvcmlnaW5TaWRlcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnbGVmdCcsICd0b3AnXSk7XG5cbi8vIEZvciB0eXBlIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB0aGUgYE9mZnNldE9wdGlvbnNgIHR5cGUgd2FzIGFsc29cbi8vIERlcml2YWJsZS5cblxuYXN5bmMgZnVuY3Rpb24gY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCxcbiAgICBwbGF0Zm9ybSxcbiAgICBlbGVtZW50c1xuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHJ0bCA9IGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKTtcbiAgY29uc3Qgc2lkZSA9IGdldFNpZGUocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gIGNvbnN0IG1haW5BeGlzTXVsdGkgPSBvcmlnaW5TaWRlcy5oYXMoc2lkZSkgPyAtMSA6IDE7XG4gIGNvbnN0IGNyb3NzQXhpc011bHRpID0gcnRsICYmIGlzVmVydGljYWwgPyAtMSA6IDE7XG4gIGNvbnN0IHJhd1ZhbHVlID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgbGV0IHtcbiAgICBtYWluQXhpcyxcbiAgICBjcm9zc0F4aXMsXG4gICAgYWxpZ25tZW50QXhpc1xuICB9ID0gdHlwZW9mIHJhd1ZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogcmF3VmFsdWUubWFpbkF4aXMgfHwgMCxcbiAgICBjcm9zc0F4aXM6IHJhd1ZhbHVlLmNyb3NzQXhpcyB8fCAwLFxuICAgIGFsaWdubWVudEF4aXM6IHJhd1ZhbHVlLmFsaWdubWVudEF4aXNcbiAgfTtcbiAgaWYgKGFsaWdubWVudCAmJiB0eXBlb2YgYWxpZ25tZW50QXhpcyA9PT0gJ251bWJlcicpIHtcbiAgICBjcm9zc0F4aXMgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gYWxpZ25tZW50QXhpcyAqIC0xIDogYWxpZ25tZW50QXhpcztcbiAgfVxuICByZXR1cm4gaXNWZXJ0aWNhbCA/IHtcbiAgICB4OiBjcm9zc0F4aXMgKiBjcm9zc0F4aXNNdWx0aSxcbiAgICB5OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGlcbiAgfSA6IHtcbiAgICB4OiBtYWluQXhpcyAqIG1haW5BeGlzTXVsdGksXG4gICAgeTogY3Jvc3NBeGlzICogY3Jvc3NBeGlzTXVsdGlcbiAgfTtcbn1cblxuLyoqXG4gKiBNb2RpZmllcyB0aGUgcGxhY2VtZW50IGJ5IHRyYW5zbGF0aW5nIHRoZSBmbG9hdGluZyBlbGVtZW50IGFsb25nIHRoZVxuICogc3BlY2lmaWVkIGF4ZXMuXG4gKiBBIG51bWJlciAoc2hvcnRoYW5kIGZvciBgbWFpbkF4aXNgIG9yIGRpc3RhbmNlKSwgb3IgYW4gYXhlcyBjb25maWd1cmF0aW9uXG4gKiBvYmplY3QgbWF5IGJlIHBhc3NlZC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9vZmZzZXRcbiAqL1xuY29uc3Qgb2Zmc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgb3B0aW9ucyxcbiAgICBhc3luYyBmbihzdGF0ZSkge1xuICAgICAgdmFyIF9taWRkbGV3YXJlRGF0YSRvZmZzZSwgX21pZGRsZXdhcmVEYXRhJGFycm93O1xuICAgICAgY29uc3Qge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIG1pZGRsZXdhcmVEYXRhXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBjb25zdCBkaWZmQ29vcmRzID0gYXdhaXQgY29udmVydFZhbHVlVG9Db29yZHMoc3RhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiB0aGUgcGxhY2VtZW50IGlzIHRoZSBzYW1lIGFuZCB0aGUgYXJyb3cgY2F1c2VkIGFuIGFsaWdubWVudCBvZmZzZXRcbiAgICAgIC8vIHRoZW4gd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uaW5nIGNvb3JkaW5hdGVzLlxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gKChfbWlkZGxld2FyZURhdGEkb2Zmc2UgPSBtaWRkbGV3YXJlRGF0YS5vZmZzZXQpID09IG51bGwgPyB2b2lkIDAgOiBfbWlkZGxld2FyZURhdGEkb2Zmc2UucGxhY2VtZW50KSAmJiAoX21pZGRsZXdhcmVEYXRhJGFycm93ID0gbWlkZGxld2FyZURhdGEuYXJyb3cpICE9IG51bGwgJiYgX21pZGRsZXdhcmVEYXRhJGFycm93LmFsaWdubWVudE9mZnNldCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgZGlmZkNvb3Jkcy54LFxuICAgICAgICB5OiB5ICsgZGlmZkNvb3Jkcy55LFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgLi4uZGlmZkNvb3JkcyxcbiAgICAgICAgICBwbGFjZW1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBzaGlmdGluZyBpdCBpbiBvcmRlciB0b1xuICoga2VlcCBpdCBpbiB2aWV3IHdoZW4gaXQgd2lsbCBvdmVyZmxvdyB0aGUgY2xpcHBpbmcgYm91bmRhcnkuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2hpZnRcbiAqL1xuY29uc3Qgc2hpZnQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiB7XG4gICAgbmFtZTogJ3NoaWZ0JyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IHN0YXRlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtYWluQXhpczogY2hlY2tNYWluQXhpcyA9IHRydWUsXG4gICAgICAgIGNyb3NzQXhpczogY2hlY2tDcm9zc0F4aXMgPSBmYWxzZSxcbiAgICAgICAgbGltaXRlciA9IHtcbiAgICAgICAgICBmbjogX3JlZiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9ID0gX3JlZjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIHlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICAgIH0gPSBldmFsdWF0ZShvcHRpb25zLCBzdGF0ZSk7XG4gICAgICBjb25zdCBjb29yZHMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH07XG4gICAgICBjb25zdCBvdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KHN0YXRlLCBkZXRlY3RPdmVyZmxvd09wdGlvbnMpO1xuICAgICAgY29uc3QgY3Jvc3NBeGlzID0gZ2V0U2lkZUF4aXMoZ2V0U2lkZShwbGFjZW1lbnQpKTtcbiAgICAgIGNvbnN0IG1haW5BeGlzID0gZ2V0T3Bwb3NpdGVBeGlzKGNyb3NzQXhpcyk7XG4gICAgICBsZXQgbWFpbkF4aXNDb29yZCA9IGNvb3Jkc1ttYWluQXhpc107XG4gICAgICBsZXQgY3Jvc3NBeGlzQ29vcmQgPSBjb29yZHNbY3Jvc3NBeGlzXTtcbiAgICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICAgIGNvbnN0IG1pblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIGNvbnN0IG1heFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBtYWluQXhpc0Nvb3JkICsgb3ZlcmZsb3dbbWluU2lkZV07XG4gICAgICAgIGNvbnN0IG1heCA9IG1haW5BeGlzQ29vcmQgLSBvdmVyZmxvd1ttYXhTaWRlXTtcbiAgICAgICAgbWFpbkF4aXNDb29yZCA9IGNsYW1wKG1pbiwgbWFpbkF4aXNDb29yZCwgbWF4KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGVja0Nyb3NzQXhpcykge1xuICAgICAgICBjb25zdCBtaW5TaWRlID0gY3Jvc3NBeGlzID09PSAneScgPyAndG9wJyA6ICdsZWZ0JztcbiAgICAgICAgY29uc3QgbWF4U2lkZSA9IGNyb3NzQXhpcyA9PT0gJ3knID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICAgICAgICBjb25zdCBtaW4gPSBjcm9zc0F4aXNDb29yZCArIG92ZXJmbG93W21pblNpZGVdO1xuICAgICAgICBjb25zdCBtYXggPSBjcm9zc0F4aXNDb29yZCAtIG92ZXJmbG93W21heFNpZGVdO1xuICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGNsYW1wKG1pbiwgY3Jvc3NBeGlzQ29vcmQsIG1heCk7XG4gICAgICB9XG4gICAgICBjb25zdCBsaW1pdGVkQ29vcmRzID0gbGltaXRlci5mbih7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubGltaXRlZENvb3JkcyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IGxpbWl0ZWRDb29yZHMueCAtIHgsXG4gICAgICAgICAgeTogbGltaXRlZENvb3Jkcy55IC0geSxcbiAgICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgICBbbWFpbkF4aXNdOiBjaGVja01haW5BeGlzLFxuICAgICAgICAgICAgW2Nyb3NzQXhpc106IGNoZWNrQ3Jvc3NBeGlzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICByZWN0cyxcbiAgICAgICAgbWlkZGxld2FyZURhdGFcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgICAgbWFpbkF4aXM6IGNoZWNrTWFpbkF4aXMgPSB0cnVlLFxuICAgICAgICBjcm9zc0F4aXM6IGNoZWNrQ3Jvc3NBeGlzID0gdHJ1ZVxuICAgICAgfSA9IGV2YWx1YXRlKG9wdGlvbnMsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNyb3NzQXhpcyA9IGdldFNpZGVBeGlzKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBtYWluQXhpcyA9IGdldE9wcG9zaXRlQXhpcyhjcm9zc0F4aXMpO1xuICAgICAgbGV0IG1haW5BeGlzQ29vcmQgPSBjb29yZHNbbWFpbkF4aXNdO1xuICAgICAgbGV0IGNyb3NzQXhpc0Nvb3JkID0gY29vcmRzW2Nyb3NzQXhpc107XG4gICAgICBjb25zdCByYXdPZmZzZXQgPSBldmFsdWF0ZShvZmZzZXQsIHN0YXRlKTtcbiAgICAgIGNvbnN0IGNvbXB1dGVkT2Zmc2V0ID0gdHlwZW9mIHJhd09mZnNldCA9PT0gJ251bWJlcicgPyB7XG4gICAgICAgIG1haW5BeGlzOiByYXdPZmZzZXQsXG4gICAgICAgIGNyb3NzQXhpczogMFxuICAgICAgfSA6IHtcbiAgICAgICAgbWFpbkF4aXM6IDAsXG4gICAgICAgIGNyb3NzQXhpczogMCxcbiAgICAgICAgLi4ucmF3T2Zmc2V0XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgY29uc3QgbGltaXRNaW4gPSByZWN0cy5yZWZlcmVuY2VbbWFpbkF4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBjb25zdCBsaW1pdE1heCA9IHJlY3RzLnJlZmVyZW5jZVttYWluQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSAtIGNvbXB1dGVkT2Zmc2V0Lm1haW5BeGlzO1xuICAgICAgICBpZiAobWFpbkF4aXNDb29yZCA8IGxpbWl0TWluKSB7XG4gICAgICAgICAgbWFpbkF4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKG1haW5BeGlzQ29vcmQgPiBsaW1pdE1heCkge1xuICAgICAgICAgIG1haW5BeGlzQ29vcmQgPSBsaW1pdE1heDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoZWNrQ3Jvc3NBeGlzKSB7XG4gICAgICAgIHZhciBfbWlkZGxld2FyZURhdGEkb2Zmc2UsIF9taWRkbGV3YXJlRGF0YSRvZmZzZTI7XG4gICAgICAgIGNvbnN0IGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG4gICAgICAgIGNvbnN0IGlzT3JpZ2luU2lkZSA9IG9yaWdpblNpZGVzLmhhcyhnZXRTaWRlKHBsYWNlbWVudCkpO1xuICAgICAgICBjb25zdCBsaW1pdE1pbiA9IHJlY3RzLnJlZmVyZW5jZVtjcm9zc0F4aXNdIC0gcmVjdHMuZmxvYXRpbmdbbGVuXSArIChpc09yaWdpblNpZGUgPyAoKF9taWRkbGV3YXJlRGF0YSRvZmZzZSA9IG1pZGRsZXdhcmVEYXRhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9taWRkbGV3YXJlRGF0YSRvZmZzZVtjcm9zc0F4aXNdKSB8fCAwIDogMCkgKyAoaXNPcmlnaW5TaWRlID8gMCA6IGNvbXB1dGVkT2Zmc2V0LmNyb3NzQXhpcyk7XG4gICAgICAgIGNvbnN0IGxpbWl0TWF4ID0gcmVjdHMucmVmZXJlbmNlW2Nyb3NzQXhpc10gKyByZWN0cy5yZWZlcmVuY2VbbGVuXSArIChpc09yaWdpblNpZGUgPyAwIDogKChfbWlkZGxld2FyZURhdGEkb2Zmc2UyID0gbWlkZGxld2FyZURhdGEub2Zmc2V0KSA9PSBudWxsID8gdm9pZCAwIDogX21pZGRsZXdhcmVEYXRhJG9mZnNlMltjcm9zc0F4aXNdKSB8fCAwKSAtIChpc09yaWdpblNpZGUgPyBjb21wdXRlZE9mZnNldC5jcm9zc0F4aXMgOiAwKTtcbiAgICAgICAgaWYgKGNyb3NzQXhpc0Nvb3JkIDwgbGltaXRNaW4pIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWluO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQXhpc0Nvb3JkID4gbGltaXRNYXgpIHtcbiAgICAgICAgICBjcm9zc0F4aXNDb29yZCA9IGxpbWl0TWF4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbbWFpbkF4aXNdOiBtYWluQXhpc0Nvb3JkLFxuICAgICAgICBbY3Jvc3NBeGlzXTogY3Jvc3NBeGlzQ29vcmRcbiAgICAgIH07XG4gICAgfVxuICB9O1xufTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRoYXQgYWxsb3dzIHlvdSB0byBjaGFuZ2UgdGhlIHNpemUgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQg4oCUXG4gKiBmb3IgaW5zdGFuY2UsIHByZXZlbnQgaXQgZnJvbSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgYm91bmRhcnkgb3IgbWF0Y2ggdGhlXG4gKiB3aWR0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvc2l6ZVxuICovXG5jb25zdCBzaXplID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdzaXplJyxcbiAgICBvcHRpb25zLFxuICAgIGFzeW5jIGZuKHN0YXRlKSB7XG4gICAgICB2YXIgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLCBfc3RhdGUkbWlkZGxld2FyZURhdGEyO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwbGFjZW1lbnQsXG4gICAgICAgIHJlY3RzLFxuICAgICAgICBwbGF0Zm9ybSxcbiAgICAgICAgZWxlbWVudHNcbiAgICAgIH0gPSBzdGF0ZTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXBwbHkgPSAoKSA9PiB7fSxcbiAgICAgICAgLi4uZGV0ZWN0T3ZlcmZsb3dPcHRpb25zXG4gICAgICB9ID0gZXZhbHVhdGUob3B0aW9ucywgc3RhdGUpO1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBhd2FpdCBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgICAgIGNvbnN0IGlzWUF4aXMgPSBnZXRTaWRlQXhpcyhwbGFjZW1lbnQpID09PSAneSc7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSByZWN0cy5mbG9hdGluZztcbiAgICAgIGxldCBoZWlnaHRTaWRlO1xuICAgICAgbGV0IHdpZHRoU2lkZTtcbiAgICAgIGlmIChzaWRlID09PSAndG9wJyB8fCBzaWRlID09PSAnYm90dG9tJykge1xuICAgICAgICBoZWlnaHRTaWRlID0gc2lkZTtcbiAgICAgICAgd2lkdGhTaWRlID0gYWxpZ25tZW50ID09PSAoKGF3YWl0IChwbGF0Zm9ybS5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogcGxhdGZvcm0uaXNSVEwoZWxlbWVudHMuZmxvYXRpbmcpKSkgPyAnc3RhcnQnIDogJ2VuZCcpID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoU2lkZSA9IHNpZGU7XG4gICAgICAgIGhlaWdodFNpZGUgPSBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ0hlaWdodCA9IGhlaWdodCAtIG92ZXJmbG93LnRvcCAtIG92ZXJmbG93LmJvdHRvbTtcbiAgICAgIGNvbnN0IG1heGltdW1DbGlwcGluZ1dpZHRoID0gd2lkdGggLSBvdmVyZmxvdy5sZWZ0IC0gb3ZlcmZsb3cucmlnaHQ7XG4gICAgICBjb25zdCBvdmVyZmxvd0F2YWlsYWJsZUhlaWdodCA9IG1pbihoZWlnaHQgLSBvdmVyZmxvd1toZWlnaHRTaWRlXSwgbWF4aW11bUNsaXBwaW5nSGVpZ2h0KTtcbiAgICAgIGNvbnN0IG92ZXJmbG93QXZhaWxhYmxlV2lkdGggPSBtaW4od2lkdGggLSBvdmVyZmxvd1t3aWR0aFNpZGVdLCBtYXhpbXVtQ2xpcHBpbmdXaWR0aCk7XG4gICAgICBjb25zdCBub1NoaWZ0ID0gIXN0YXRlLm1pZGRsZXdhcmVEYXRhLnNoaWZ0O1xuICAgICAgbGV0IGF2YWlsYWJsZUhlaWdodCA9IG92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgbGV0IGF2YWlsYWJsZVdpZHRoID0gb3ZlcmZsb3dBdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmICgoX3N0YXRlJG1pZGRsZXdhcmVEYXRhID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhLmVuYWJsZWQueCkge1xuICAgICAgICBhdmFpbGFibGVXaWR0aCA9IG1heGltdW1DbGlwcGluZ1dpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKChfc3RhdGUkbWlkZGxld2FyZURhdGEyID0gc3RhdGUubWlkZGxld2FyZURhdGEuc2hpZnQpICE9IG51bGwgJiYgX3N0YXRlJG1pZGRsZXdhcmVEYXRhMi5lbmFibGVkLnkpIHtcbiAgICAgICAgYXZhaWxhYmxlSGVpZ2h0ID0gbWF4aW11bUNsaXBwaW5nSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKG5vU2hpZnQgJiYgIWFsaWdubWVudCkge1xuICAgICAgICBjb25zdCB4TWluID0gbWF4KG92ZXJmbG93LmxlZnQsIDApO1xuICAgICAgICBjb25zdCB4TWF4ID0gbWF4KG92ZXJmbG93LnJpZ2h0LCAwKTtcbiAgICAgICAgY29uc3QgeU1pbiA9IG1heChvdmVyZmxvdy50b3AsIDApO1xuICAgICAgICBjb25zdCB5TWF4ID0gbWF4KG92ZXJmbG93LmJvdHRvbSwgMCk7XG4gICAgICAgIGlmIChpc1lBeGlzKSB7XG4gICAgICAgICAgYXZhaWxhYmxlV2lkdGggPSB3aWR0aCAtIDIgKiAoeE1pbiAhPT0gMCB8fCB4TWF4ICE9PSAwID8geE1pbiArIHhNYXggOiBtYXgob3ZlcmZsb3cubGVmdCwgb3ZlcmZsb3cucmlnaHQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdmFpbGFibGVIZWlnaHQgPSBoZWlnaHQgLSAyICogKHlNaW4gIT09IDAgfHwgeU1heCAhPT0gMCA/IHlNaW4gKyB5TWF4IDogbWF4KG92ZXJmbG93LnRvcCwgb3ZlcmZsb3cuYm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGFwcGx5KHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgICBhdmFpbGFibGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmV4dERpbWVuc2lvbnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXREaW1lbnNpb25zKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGlmICh3aWR0aCAhPT0gbmV4dERpbWVuc2lvbnMud2lkdGggfHwgaGVpZ2h0ICE9PSBuZXh0RGltZW5zaW9ucy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByZXNldDoge1xuICAgICAgICAgICAgcmVjdHM6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSB9O1xuIl0sIm5hbWVzIjpbImdldFNpZGVBeGlzIiwiZ2V0QWxpZ25tZW50QXhpcyIsImdldEF4aXNMZW5ndGgiLCJnZXRTaWRlIiwiZ2V0QWxpZ25tZW50IiwiZXZhbHVhdGUiLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsIm1pbiIsImNsYW1wIiwicGxhY2VtZW50cyIsImdldEFsaWdubWVudFNpZGVzIiwiZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsImdldEV4cGFuZGVkUGxhY2VtZW50cyIsImdldE9wcG9zaXRlQXhpc1BsYWNlbWVudHMiLCJzaWRlcyIsIm1heCIsImdldE9wcG9zaXRlQXhpcyIsImNvbXB1dGVDb29yZHNGcm9tUGxhY2VtZW50IiwiX3JlZiIsInBsYWNlbWVudCIsInJ0bCIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwic2lkZUF4aXMiLCJhbGlnbm1lbnRBeGlzIiwiYWxpZ25MZW5ndGgiLCJzaWRlIiwiaXNWZXJ0aWNhbCIsImNvbW1vblgiLCJ4Iiwid2lkdGgiLCJjb21tb25ZIiwieSIsImhlaWdodCIsImNvbW1vbkFsaWduIiwiY29vcmRzIiwiY29tcHV0ZVBvc2l0aW9uIiwiY29uZmlnIiwic3RyYXRlZ3kiLCJtaWRkbGV3YXJlIiwicGxhdGZvcm0iLCJ2YWxpZE1pZGRsZXdhcmUiLCJmaWx0ZXIiLCJCb29sZWFuIiwiaXNSVEwiLCJyZWN0cyIsImdldEVsZW1lbnRSZWN0cyIsInN0YXRlZnVsUGxhY2VtZW50IiwibWlkZGxld2FyZURhdGEiLCJyZXNldENvdW50IiwiaSIsImxlbmd0aCIsIm5hbWUiLCJmbiIsIm5leHRYIiwibmV4dFkiLCJkYXRhIiwicmVzZXQiLCJpbml0aWFsUGxhY2VtZW50IiwiZWxlbWVudHMiLCJkZXRlY3RPdmVyZmxvdyIsInN0YXRlIiwib3B0aW9ucyIsIl9hd2FpdCRwbGF0Zm9ybSRpc0VsZSIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwiZWxlbWVudENvbnRleHQiLCJhbHRCb3VuZGFyeSIsInBhZGRpbmciLCJwYWRkaW5nT2JqZWN0IiwiYWx0Q29udGV4dCIsImVsZW1lbnQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJnZXRDbGlwcGluZ1JlY3QiLCJpc0VsZW1lbnQiLCJjb250ZXh0RWxlbWVudCIsImdldERvY3VtZW50RWxlbWVudCIsInJlY3QiLCJvZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJvZmZzZXRTY2FsZSIsImdldFNjYWxlIiwiZWxlbWVudENsaWVudFJlY3QiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImFycm93IiwiYXhpcyIsImFycm93RGltZW5zaW9ucyIsImdldERpbWVuc2lvbnMiLCJpc1lBeGlzIiwibWluUHJvcCIsIm1heFByb3AiLCJjbGllbnRQcm9wIiwiZW5kRGlmZiIsInN0YXJ0RGlmZiIsImFycm93T2Zmc2V0UGFyZW50IiwiY2xpZW50U2l6ZSIsImNlbnRlclRvUmVmZXJlbmNlIiwibGFyZ2VzdFBvc3NpYmxlUGFkZGluZyIsIm1pblBhZGRpbmciLCJtYXhQYWRkaW5nIiwibWluJDEiLCJjZW50ZXIiLCJvZmZzZXQiLCJzaG91bGRBZGRPZmZzZXQiLCJhbGlnbm1lbnRPZmZzZXQiLCJjZW50ZXJPZmZzZXQiLCJnZXRQbGFjZW1lbnRMaXN0IiwiYWxpZ25tZW50IiwiYXV0b0FsaWdubWVudCIsImFsbG93ZWRQbGFjZW1lbnRzIiwiYWxsb3dlZFBsYWNlbWVudHNTb3J0ZWRCeUFsaWdubWVudCIsImF1dG9QbGFjZW1lbnQiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AiLCJfbWlkZGxld2FyZURhdGEkYXV0b1AyIiwiX3BsYWNlbWVudHNUaGF0Rml0T25FIiwiY3Jvc3NBeGlzIiwiZGV0ZWN0T3ZlcmZsb3dPcHRpb25zIiwicGxhY2VtZW50cyQxIiwidW5kZWZpbmVkIiwib3ZlcmZsb3ciLCJjdXJyZW50SW5kZXgiLCJpbmRleCIsImN1cnJlbnRQbGFjZW1lbnQiLCJhbGlnbm1lbnRTaWRlcyIsImN1cnJlbnRPdmVyZmxvd3MiLCJhbGxPdmVyZmxvd3MiLCJvdmVyZmxvd3MiLCJuZXh0UGxhY2VtZW50IiwicGxhY2VtZW50c1NvcnRlZEJ5TW9zdFNwYWNlIiwibWFwIiwiZCIsInNsaWNlIiwicmVkdWNlIiwiYWNjIiwidiIsInNvcnQiLCJhIiwiYiIsInBsYWNlbWVudHNUaGF0Rml0T25FYWNoU2lkZSIsImV2ZXJ5IiwicmVzZXRQbGFjZW1lbnQiLCJmbGlwIiwiX21pZGRsZXdhcmVEYXRhJGFycm93IiwiX21pZGRsZXdhcmVEYXRhJGZsaXAiLCJtYWluQXhpcyIsImNoZWNrTWFpbkF4aXMiLCJjaGVja0Nyb3NzQXhpcyIsImZhbGxiYWNrUGxhY2VtZW50cyIsInNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyIsImZhbGxiYWNrU3RyYXRlZ3kiLCJmYWxsYmFja0F4aXNTaWRlRGlyZWN0aW9uIiwiZmxpcEFsaWdubWVudCIsImluaXRpYWxTaWRlQXhpcyIsImlzQmFzZVBsYWNlbWVudCIsImhhc0ZhbGxiYWNrQXhpc1NpZGVEaXJlY3Rpb24iLCJwdXNoIiwib3ZlcmZsb3dzRGF0YSIsIl9taWRkbGV3YXJlRGF0YSRmbGlwMiIsIl9vdmVyZmxvd3NEYXRhJGZpbHRlciIsIm5leHRJbmRleCIsImlnbm9yZUNyb3NzQXhpc092ZXJmbG93IiwiX292ZXJmbG93c0RhdGEkZmlsdGVyMiIsImN1cnJlbnRTaWRlQXhpcyIsImdldFNpZGVPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsImhpZGUiLCJvZmZzZXRzIiwicmVmZXJlbmNlSGlkZGVuT2Zmc2V0cyIsInJlZmVyZW5jZUhpZGRlbiIsImVzY2FwZWRPZmZzZXRzIiwiZXNjYXBlZCIsImdldEJvdW5kaW5nUmVjdCIsIm1pblgiLCJtaW5ZIiwibWF4WCIsIm1heFkiLCJnZXRSZWN0c0J5TGluZSIsInNvcnRlZFJlY3RzIiwiZ3JvdXBzIiwicHJldlJlY3QiLCJpbmxpbmUiLCJuYXRpdmVDbGllbnRSZWN0cyIsIkFycmF5IiwiZnJvbSIsImdldENsaWVudFJlY3RzIiwiY2xpZW50UmVjdHMiLCJmYWxsYmFjayIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImZpbmQiLCJmaXJzdFJlY3QiLCJsYXN0UmVjdCIsImlzVG9wIiwiaXNMZWZ0U2lkZSIsIm1heFJpZ2h0IiwibWluTGVmdCIsIm1lYXN1cmVSZWN0cyIsInJlc2V0UmVjdHMiLCJvcmlnaW5TaWRlcyIsIlNldCIsImNvbnZlcnRWYWx1ZVRvQ29vcmRzIiwibWFpbkF4aXNNdWx0aSIsImhhcyIsImNyb3NzQXhpc011bHRpIiwicmF3VmFsdWUiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UiLCJkaWZmQ29vcmRzIiwic2hpZnQiLCJsaW1pdGVyIiwibWFpbkF4aXNDb29yZCIsImNyb3NzQXhpc0Nvb3JkIiwibWluU2lkZSIsIm1heFNpZGUiLCJsaW1pdGVkQ29vcmRzIiwiZW5hYmxlZCIsImxpbWl0U2hpZnQiLCJyYXdPZmZzZXQiLCJjb21wdXRlZE9mZnNldCIsImxlbiIsImxpbWl0TWluIiwibGltaXRNYXgiLCJfbWlkZGxld2FyZURhdGEkb2Zmc2UyIiwiaXNPcmlnaW5TaWRlIiwic2l6ZSIsIl9zdGF0ZSRtaWRkbGV3YXJlRGF0YSIsIl9zdGF0ZSRtaWRkbGV3YXJlRGF0YTIiLCJhcHBseSIsImhlaWdodFNpZGUiLCJ3aWR0aFNpZGUiLCJtYXhpbXVtQ2xpcHBpbmdIZWlnaHQiLCJtYXhpbXVtQ2xpcHBpbmdXaWR0aCIsIm92ZXJmbG93QXZhaWxhYmxlSGVpZ2h0Iiwib3ZlcmZsb3dBdmFpbGFibGVXaWR0aCIsIm5vU2hpZnQiLCJhdmFpbGFibGVIZWlnaHQiLCJhdmFpbGFibGVXaWR0aCIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJuZXh0RGltZW5zaW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* binding */ autoUpdate),\n/* harmony export */   computePosition: () => (/* binding */ computePosition),\n/* harmony export */   detectOverflow: () => (/* binding */ detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/core */ \"(ssr)/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs\");\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n\n\n\n\nfunction getCssDimensions(element) {\n  const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(width) !== offsetWidth || (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\nfunction unwrapElement(element) {\n  return !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.contextElement : element;\n}\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(domElement)) {\n    return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) : rect.width) / width;\n  let y = ($ ? (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nconst noOffsets = /*#__PURE__*/(0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\nfunction getVisualOffsets(element) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element)) {\n    return false;\n  }\n  return isFixed;\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(domElement);\n    const offsetWin = offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(offsetParent) ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(currentIFrame);\n      currentIFrame = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getFrameElement)(currentWin);\n    }\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\nfunction getHTMLOffset(documentElement, scroll) {\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const topLayer = elements ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(element);\n  const body = element.ownerDocument.body;\n  const width = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(body).direction === 'rtl') {\n    x += (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Safety check: ensure the scrollbar space is reasonable in case this\n// calculation is affected by unusual styles.\n// Most scrollbars leave 15-18px of space.\nconst SCROLLBAR_MAX = 25;\nfunction getViewportRect(element, strategy) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  const html = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isWebKit)();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  const windowScrollbarX = getWindowScrollBarX(html);\n  // <html> `overflow: hidden` + `scrollbar-gutter: stable` reduces the\n  // visual width of the <html> but this is not considered in the size\n  // of `html.clientWidth`.\n  if (windowScrollbarX <= 0) {\n    const doc = html.ownerDocument;\n    const body = doc.body;\n    const bodyStyles = getComputedStyle(body);\n    const bodyMarginInline = doc.compatMode === 'CSS1Compat' ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;\n    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);\n    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {\n      width -= clippingStableScrollbarWidth;\n    }\n  } else if (windowScrollbarX <= SCROLLBAR_MAX) {\n    // If the <body> scrollbar is on the left, the width needs to be extended\n    // by the scrollbar amount so there isn't extra space on the right.\n    width += windowScrollbarX;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nconst absoluteOrFixed = /*#__PURE__*/new Set(['absolute', 'fixed']);\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? getScale(element) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element));\n  } else if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.rectToClientRect)(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n  if (parentNode === stopNode || !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(parentNode) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(parentNode)) {\n    return false;\n  }\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(element, [], false).filter(el => (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed';\n  let currentNode = elementIsFixed ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(currentNode) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(currentNode)) {\n    const computedStyle = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(currentNode);\n    const currentNodeIsContaining = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.top, accRect.top);\n    accRect.right = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(offsetParent);\n  const documentElement = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n\n  // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n  // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n  function setLeftRTLScrollbarOffset() {\n    offsets.x = getWindowScrollBarX(documentElement);\n  }\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeName)(offsetParent) !== 'body' || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isOverflowElement)(documentElement)) {\n      scroll = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getNodeScroll)(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      setLeftRTLScrollbarOffset();\n    }\n  }\n  if (isFixed && !isOffsetParentAnElement && documentElement) {\n    setLeftRTLScrollbarOffset();\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.createCoords)(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction isStaticPositioned(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'static';\n}\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getWindow)(element);\n  if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTopLayer)(element)) {\n    return win;\n  }\n  if (!(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    let svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(element);\n    while (svgOffsetParent && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(svgOffsetParent)) {\n      if ((0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement)(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getParentNode)(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isTableElement)(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isLastTraversableNode)(offsetParent) && isStaticPositioned(offsetParent) && !(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isContainingBlock)(offsetParent)) {\n    return win;\n  }\n  return offsetParent || (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getContainingBlock)(element) || win;\n}\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\nfunction isRTL(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getComputedStyle)(element).direction === 'rtl';\n}\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement: _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.isElement,\n  isRTL\n};\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getDocumentElement)(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(top);\n    const insetRight = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientWidth - (left + width));\n    const insetBottom = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(root.clientHeight - (top + height));\n    const insetLeft = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.floor)(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.max)(0, (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_1__.min)(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (_e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(referenceEl) : []), ...(0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_0__.getOverflowAncestors)(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.detectOverflow;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.offset;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.autoPlacement;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.shift;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.flip;\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.size;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.hide;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.arrow;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.inline;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = _floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.limitShift;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return (0,_floating_ui_core__WEBPACK_IMPORTED_MODULE_2__.computePosition)(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeVQ7QUFDL087QUFDd1E7QUFDcFI7QUFFOUQsU0FBUzhDLGdCQUFnQkEsQ0FBQ0MsT0FBTyxFQUFFO0VBQ2pDLE1BQU1DLEdBQUcsR0FBR25CLHdFQUFrQixDQUFDa0IsT0FBTyxDQUFDO0VBQ3ZDO0VBQ0E7RUFDQSxJQUFJRSxLQUFLLEdBQUdDLFVBQVUsQ0FBQ0YsR0FBRyxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDO0VBQ3RDLElBQUlFLE1BQU0sR0FBR0QsVUFBVSxDQUFDRixHQUFHLENBQUNHLE1BQU0sQ0FBQyxJQUFJLENBQUM7RUFDeEMsTUFBTUMsU0FBUyxHQUFHdEIscUVBQWEsQ0FBQ2lCLE9BQU8sQ0FBQztFQUN4QyxNQUFNTSxXQUFXLEdBQUdELFNBQVMsR0FBR0wsT0FBTyxDQUFDTSxXQUFXLEdBQUdKLEtBQUs7RUFDM0QsTUFBTUssWUFBWSxHQUFHRixTQUFTLEdBQUdMLE9BQU8sQ0FBQ08sWUFBWSxHQUFHSCxNQUFNO0VBQzlELE1BQU1JLGNBQWMsR0FBR2hDLHlEQUFLLENBQUMwQixLQUFLLENBQUMsS0FBS0ksV0FBVyxJQUFJOUIseURBQUssQ0FBQzRCLE1BQU0sQ0FBQyxLQUFLRyxZQUFZO0VBQ3JGLElBQUlDLGNBQWMsRUFBRTtJQUNsQk4sS0FBSyxHQUFHSSxXQUFXO0lBQ25CRixNQUFNLEdBQUdHLFlBQVk7RUFDdkI7RUFDQSxPQUFPO0lBQ0xMLEtBQUs7SUFDTEUsTUFBTTtJQUNOSyxDQUFDLEVBQUVEO0VBQ0wsQ0FBQztBQUNIO0FBRUEsU0FBU0UsYUFBYUEsQ0FBQ1YsT0FBTyxFQUFFO0VBQzlCLE9BQU8sQ0FBQ2hCLGlFQUFTLENBQUNnQixPQUFPLENBQUMsR0FBR0EsT0FBTyxDQUFDVyxjQUFjLEdBQUdYLE9BQU87QUFDL0Q7QUFFQSxTQUFTWSxRQUFR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LFFBQVEsRUFBRTtJQUM1QyxHQUFHaUosYUFBYTtJQUNoQjdELFFBQVEsRUFBRThEO0VBQ1osQ0FBQyxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bvcy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL2RvbS9kaXN0L2Zsb2F0aW5nLXVpLmRvbS5tanM/M2ZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZWN0VG9DbGllbnRSZWN0LCBhcnJvdyBhcyBhcnJvdyQxLCBhdXRvUGxhY2VtZW50IGFzIGF1dG9QbGFjZW1lbnQkMSwgZGV0ZWN0T3ZlcmZsb3cgYXMgZGV0ZWN0T3ZlcmZsb3ckMSwgZmxpcCBhcyBmbGlwJDEsIGhpZGUgYXMgaGlkZSQxLCBpbmxpbmUgYXMgaW5saW5lJDEsIGxpbWl0U2hpZnQgYXMgbGltaXRTaGlmdCQxLCBvZmZzZXQgYXMgb2Zmc2V0JDEsIHNoaWZ0IGFzIHNoaWZ0JDEsIHNpemUgYXMgc2l6ZSQxLCBjb21wdXRlUG9zaXRpb24gYXMgY29tcHV0ZVBvc2l0aW9uJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvY29yZSc7XG5pbXBvcnQgeyByb3VuZCwgY3JlYXRlQ29vcmRzLCBtYXgsIG1pbiwgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSBhcyBnZXRDb21wdXRlZFN0eWxlJDEsIGlzSFRNTEVsZW1lbnQsIGlzRWxlbWVudCwgZ2V0V2luZG93LCBpc1dlYktpdCwgZ2V0RnJhbWVFbGVtZW50LCBnZXROb2RlU2Nyb2xsLCBnZXREb2N1bWVudEVsZW1lbnQsIGlzVG9wTGF5ZXIsIGdldE5vZGVOYW1lLCBpc092ZXJmbG93RWxlbWVudCwgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIGdldFBhcmVudE5vZGUsIGlzTGFzdFRyYXZlcnNhYmxlTm9kZSwgaXNDb250YWluaW5nQmxvY2ssIGlzVGFibGVFbGVtZW50LCBnZXRDb250YWluaW5nQmxvY2sgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMvZG9tJztcbmV4cG9ydCB7IGdldE92ZXJmbG93QW5jZXN0b3JzIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzL2RvbSc7XG5cbmZ1bmN0aW9uIGdldENzc0RpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCBjc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XG4gIC8vIEluIHRlc3RpbmcgZW52aXJvbm1lbnRzLCB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBhcmUgZW1wdHlcbiAgLy8gc3RyaW5ncyBmb3IgU1ZHIGVsZW1lbnRzLCByZXR1cm5pbmcgTmFOLiBGYWxsYmFjayB0byBgMGAgaW4gdGhpcyBjYXNlLlxuICBsZXQgd2lkdGggPSBwYXJzZUZsb2F0KGNzcy53aWR0aCkgfHwgMDtcbiAgbGV0IGhlaWdodCA9IHBhcnNlRmxvYXQoY3NzLmhlaWdodCkgfHwgMDtcbiAgY29uc3QgaGFzT2Zmc2V0ID0gaXNIVE1MRWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgb2Zmc2V0V2lkdGggPSBoYXNPZmZzZXQgPyBlbGVtZW50Lm9mZnNldFdpZHRoIDogd2lkdGg7XG4gIGNvbnN0IG9mZnNldEhlaWdodCA9IGhhc09mZnNldCA/IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IDogaGVpZ2h0O1xuICBjb25zdCBzaG91bGRGYWxsYmFjayA9IHJvdW5kKHdpZHRoKSAhPT0gb2Zmc2V0V2lkdGggfHwgcm91bmQoaGVpZ2h0KSAhPT0gb2Zmc2V0SGVpZ2h0O1xuICBpZiAoc2hvdWxkRmFsbGJhY2spIHtcbiAgICB3aWR0aCA9IG9mZnNldFdpZHRoO1xuICAgIGhlaWdodCA9IG9mZnNldEhlaWdodDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkOiBzaG91bGRGYWxsYmFja1xuICB9O1xufVxuXG5mdW5jdGlvbiB1bndyYXBFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuICFpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LmNvbnRleHRFbGVtZW50IDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gdW53cmFwRWxlbWVudChlbGVtZW50KTtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvb3JkcygxKTtcbiAgfVxuICBjb25zdCByZWN0ID0gZG9tRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICAkXG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGRvbUVsZW1lbnQpO1xuICBsZXQgeCA9ICgkID8gcm91bmQocmVjdC53aWR0aCkgOiByZWN0LndpZHRoKSAvIHdpZHRoO1xuICBsZXQgeSA9ICgkID8gcm91bmQocmVjdC5oZWlnaHQpIDogcmVjdC5oZWlnaHQpIC8gaGVpZ2h0O1xuXG4gIC8vIDAsIE5hTiwgb3IgSW5maW5pdHkgc2hvdWxkIGFsd2F5cyBmYWxsYmFjayB0byAxLlxuXG4gIGlmICgheCB8fCAhTnVtYmVyLmlzRmluaXRlKHgpKSB7XG4gICAgeCA9IDE7XG4gIH1cbiAgaWYgKCF5IHx8ICFOdW1iZXIuaXNGaW5pdGUoeSkpIHtcbiAgICB5ID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeVxuICB9O1xufVxuXG5jb25zdCBub09mZnNldHMgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29vcmRzKDApO1xuZnVuY3Rpb24gZ2V0VmlzdWFsT2Zmc2V0cyhlbGVtZW50KSB7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgaWYgKCFpc1dlYktpdCgpIHx8ICF3aW4udmlzdWFsVmlld3BvcnQpIHtcbiAgICByZXR1cm4gbm9PZmZzZXRzO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQsXG4gICAgeTogd2luLnZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcFxuICB9O1xufVxuZnVuY3Rpb24gc2hvdWxkQWRkVmlzdWFsT2Zmc2V0cyhlbGVtZW50LCBpc0ZpeGVkLCBmbG9hdGluZ09mZnNldFBhcmVudCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG4gIGlmICghZmxvYXRpbmdPZmZzZXRQYXJlbnQgfHwgaXNGaXhlZCAmJiBmbG9hdGluZ09mZnNldFBhcmVudCAhPT0gZ2V0V2luZG93KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3ksIG9mZnNldFBhcmVudCkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IHVud3JhcEVsZW1lbnQoZWxlbWVudCk7XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgaWYgKGluY2x1ZGVTY2FsZSkge1xuICAgIGlmIChvZmZzZXRQYXJlbnQpIHtcbiAgICAgIGlmIChpc0VsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlID0gZ2V0U2NhbGUoZWxlbWVudCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBzaG91bGRBZGRWaXN1YWxPZmZzZXRzKGRvbUVsZW1lbnQsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSA/IGdldFZpc3VhbE9mZnNldHMoZG9tRWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGxldCB4ID0gKGNsaWVudFJlY3QubGVmdCArIHZpc3VhbE9mZnNldHMueCkgLyBzY2FsZS54O1xuICBsZXQgeSA9IChjbGllbnRSZWN0LnRvcCArIHZpc3VhbE9mZnNldHMueSkgLyBzY2FsZS55O1xuICBsZXQgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgbGV0IGhlaWdodCA9IGNsaWVudFJlY3QuaGVpZ2h0IC8gc2NhbGUueTtcbiAgaWYgKGRvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZG9tRWxlbWVudCk7XG4gICAgY29uc3Qgb2Zmc2V0V2luID0gb2Zmc2V0UGFyZW50ICYmIGlzRWxlbWVudChvZmZzZXRQYXJlbnQpID8gZ2V0V2luZG93KG9mZnNldFBhcmVudCkgOiBvZmZzZXRQYXJlbnQ7XG4gICAgbGV0IGN1cnJlbnRXaW4gPSB3aW47XG4gICAgbGV0IGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgd2hpbGUgKGN1cnJlbnRJRnJhbWUgJiYgb2Zmc2V0UGFyZW50ICYmIG9mZnNldFdpbiAhPT0gY3VycmVudFdpbikge1xuICAgICAgY29uc3QgaWZyYW1lU2NhbGUgPSBnZXRTY2FsZShjdXJyZW50SUZyYW1lKTtcbiAgICAgIGNvbnN0IGlmcmFtZVJlY3QgPSBjdXJyZW50SUZyYW1lLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnRJRnJhbWUpO1xuICAgICAgY29uc3QgbGVmdCA9IGlmcmFtZVJlY3QubGVmdCArIChjdXJyZW50SUZyYW1lLmNsaWVudExlZnQgKyBwYXJzZUZsb2F0KGNzcy5wYWRkaW5nTGVmdCkpICogaWZyYW1lU2NhbGUueDtcbiAgICAgIGNvbnN0IHRvcCA9IGlmcmFtZVJlY3QudG9wICsgKGN1cnJlbnRJRnJhbWUuY2xpZW50VG9wICsgcGFyc2VGbG9hdChjc3MucGFkZGluZ1RvcCkpICogaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKj0gaWZyYW1lU2NhbGUueDtcbiAgICAgIHkgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHdpZHRoICo9IGlmcmFtZVNjYWxlLng7XG4gICAgICBoZWlnaHQgKj0gaWZyYW1lU2NhbGUueTtcbiAgICAgIHggKz0gbGVmdDtcbiAgICAgIHkgKz0gdG9wO1xuICAgICAgY3VycmVudFdpbiA9IGdldFdpbmRvdyhjdXJyZW50SUZyYW1lKTtcbiAgICAgIGN1cnJlbnRJRnJhbWUgPSBnZXRGcmFtZUVsZW1lbnQoY3VycmVudFdpbik7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH0pO1xufVxuXG4vLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4vLyBpbmNvcnJlY3QgZm9yIFJUTC5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCwgcmVjdCkge1xuICBjb25zdCBsZWZ0U2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xuICBpZiAoIXJlY3QpIHtcbiAgICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGxlZnRTY3JvbGw7XG4gIH1cbiAgcmV0dXJuIHJlY3QubGVmdCArIGxlZnRTY3JvbGw7XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIHtcbiAgY29uc3QgaHRtbFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHggPSBodG1sUmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCwgaHRtbFJlY3QpO1xuICBjb25zdCB5ID0gaHRtbFJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcDtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnRzLFxuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc0ZpeGVkID0gc3RyYXRlZ3kgPT09ICdmaXhlZCc7XG4gIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCB0b3BMYXllciA9IGVsZW1lbnRzID8gaXNUb3BMYXllcihlbGVtZW50cy5mbG9hdGluZykgOiBmYWxzZTtcbiAgaWYgKG9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnRFbGVtZW50IHx8IHRvcExheWVyICYmIGlzRml4ZWQpIHtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuICBsZXQgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIGxldCBzY2FsZSA9IGNyZWF0ZUNvb3JkcygxKTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcbiAgY29uc3QgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgY29uc3Qgb2Zmc2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgb2Zmc2V0cy54ID0gb2Zmc2V0UmVjdC54ICsgb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgPSBvZmZzZXRSZWN0LnkgKyBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH1cbiAgfVxuICBjb25zdCBodG1sT2Zmc2V0ID0gZG9jdW1lbnRFbGVtZW50ICYmICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCA/IGdldEhUTUxPZmZzZXQoZG9jdW1lbnRFbGVtZW50LCBzY3JvbGwpIDogY3JlYXRlQ29vcmRzKDApO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0LndpZHRoICogc2NhbGUueCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogc2NhbGUueSxcbiAgICB4OiByZWN0LnggKiBzY2FsZS54IC0gc2Nyb2xsLnNjcm9sbExlZnQgKiBzY2FsZS54ICsgb2Zmc2V0cy54ICsgaHRtbE9mZnNldC54LFxuICAgIHk6IHJlY3QueSAqIHNjYWxlLnkgLSBzY3JvbGwuc2Nyb2xsVG9wICogc2NhbGUueSArIG9mZnNldHMueSArIGh0bWxPZmZzZXQueVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0cyhlbGVtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSk7XG59XG5cbi8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGUuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKGVsZW1lbnQpO1xuICBjb25zdCBib2R5ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkuc2Nyb2xsV2lkdGgsIGJvZHkuY2xpZW50V2lkdGgpO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5LnNjcm9sbEhlaWdodCwgYm9keS5jbGllbnRIZWlnaHQpO1xuICBsZXQgeCA9IC1zY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIGNvbnN0IHkgPSAtc2Nyb2xsLnNjcm9sbFRvcDtcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUkMShib2R5KS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keS5jbGllbnRXaWR0aCkgLSB3aWR0aDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuLy8gU2FmZXR5IGNoZWNrOiBlbnN1cmUgdGhlIHNjcm9sbGJhciBzcGFjZSBpcyByZWFzb25hYmxlIGluIGNhc2UgdGhpc1xuLy8gY2FsY3VsYXRpb24gaXMgYWZmZWN0ZWQgYnkgdW51c3VhbCBzdHlsZXMuXG4vLyBNb3N0IHNjcm9sbGJhcnMgbGVhdmUgMTUtMThweCBvZiBzcGFjZS5cbmNvbnN0IFNDUk9MTEJBUl9NQVggPSAyNTtcbmZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGNvbnN0IGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGNvbnN0IHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xuICBsZXQgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICBsZXQgaGVpZ2h0ID0gaHRtbC5jbGllbnRIZWlnaHQ7XG4gIGxldCB4ID0gMDtcbiAgbGV0IHkgPSAwO1xuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICBjb25zdCB2aXN1YWxWaWV3cG9ydEJhc2VkID0gaXNXZWJLaXQoKTtcbiAgICBpZiAoIXZpc3VhbFZpZXdwb3J0QmFzZWQgfHwgdmlzdWFsVmlld3BvcnRCYXNlZCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuICBjb25zdCB3aW5kb3dTY3JvbGxiYXJYID0gZ2V0V2luZG93U2Nyb2xsQmFyWChodG1sKTtcbiAgLy8gPGh0bWw+IGBvdmVyZmxvdzogaGlkZGVuYCArIGBzY3JvbGxiYXItZ3V0dGVyOiBzdGFibGVgIHJlZHVjZXMgdGhlXG4gIC8vIHZpc3VhbCB3aWR0aCBvZiB0aGUgPGh0bWw+IGJ1dCB0aGlzIGlzIG5vdCBjb25zaWRlcmVkIGluIHRoZSBzaXplXG4gIC8vIG9mIGBodG1sLmNsaWVudFdpZHRoYC5cbiAgaWYgKHdpbmRvd1Njcm9sbGJhclggPD0gMCkge1xuICAgIGNvbnN0IGRvYyA9IGh0bWwub3duZXJEb2N1bWVudDtcbiAgICBjb25zdCBib2R5ID0gZG9jLmJvZHk7XG4gICAgY29uc3QgYm9keVN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoYm9keSk7XG4gICAgY29uc3QgYm9keU1hcmdpbklubGluZSA9IGRvYy5jb21wYXRNb2RlID09PSAnQ1NTMUNvbXBhdCcgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZXMubWFyZ2luTGVmdCkgKyBwYXJzZUZsb2F0KGJvZHlTdHlsZXMubWFyZ2luUmlnaHQpIHx8IDAgOiAwO1xuICAgIGNvbnN0IGNsaXBwaW5nU3RhYmxlU2Nyb2xsYmFyV2lkdGggPSBNYXRoLmFicyhodG1sLmNsaWVudFdpZHRoIC0gYm9keS5jbGllbnRXaWR0aCAtIGJvZHlNYXJnaW5JbmxpbmUpO1xuICAgIGlmIChjbGlwcGluZ1N0YWJsZVNjcm9sbGJhcldpZHRoIDw9IFNDUk9MTEJBUl9NQVgpIHtcbiAgICAgIHdpZHRoIC09IGNsaXBwaW5nU3RhYmxlU2Nyb2xsYmFyV2lkdGg7XG4gICAgfVxuICB9IGVsc2UgaWYgKHdpbmRvd1Njcm9sbGJhclggPD0gU0NST0xMQkFSX01BWCkge1xuICAgIC8vIElmIHRoZSA8Ym9keT4gc2Nyb2xsYmFyIGlzIG9uIHRoZSBsZWZ0LCB0aGUgd2lkdGggbmVlZHMgdG8gYmUgZXh0ZW5kZWRcbiAgICAvLyBieSB0aGUgc2Nyb2xsYmFyIGFtb3VudCBzbyB0aGVyZSBpc24ndCBleHRyYSBzcGFjZSBvbiB0aGUgcmlnaHQuXG4gICAgd2lkdGggKz0gd2luZG93U2Nyb2xsYmFyWDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cblxuY29uc3QgYWJzb2x1dGVPckZpeGVkID0gLyojX19QVVJFX18qL25ldyBTZXQoWydhYnNvbHV0ZScsICdmaXhlZCddKTtcbi8vIFJldHVybnMgdGhlIGlubmVyIGNsaWVudCByZWN0LCBzdWJ0cmFjdGluZyBzY3JvbGxiYXJzIGlmIHByZXNlbnQuXG5mdW5jdGlvbiBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBjbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgY29uc3QgdG9wID0gY2xpZW50UmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgY29uc3QgbGVmdCA9IGNsaWVudFJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgY29uc3Qgc2NhbGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0U2NhbGUoZWxlbWVudCkgOiBjcmVhdGVDb29yZHMoMSk7XG4gIGNvbnN0IHdpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aCAqIHNjYWxlLng7XG4gIGNvbnN0IGhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICogc2NhbGUueTtcbiAgY29uc3QgeCA9IGxlZnQgKiBzY2FsZS54O1xuICBjb25zdCB5ID0gdG9wICogc2NhbGUueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbUNsaXBwaW5nQW5jZXN0b3IoZWxlbWVudCwgY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpIHtcbiAgbGV0IHJlY3Q7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSAndmlld3BvcnQnKSB7XG4gICAgcmVjdCA9IGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSk7XG4gIH0gZWxzZSBpZiAoY2xpcHBpbmdBbmNlc3RvciA9PT0gJ2RvY3VtZW50Jykge1xuICAgIHJlY3QgPSBnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgfSBlbHNlIGlmIChpc0VsZW1lbnQoY2xpcHBpbmdBbmNlc3RvcikpIHtcbiAgICByZWN0ID0gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpc3VhbE9mZnNldHMgPSBnZXRWaXN1YWxPZmZzZXRzKGVsZW1lbnQpO1xuICAgIHJlY3QgPSB7XG4gICAgICB4OiBjbGlwcGluZ0FuY2VzdG9yLnggLSB2aXN1YWxPZmZzZXRzLngsXG4gICAgICB5OiBjbGlwcGluZ0FuY2VzdG9yLnkgLSB2aXN1YWxPZmZzZXRzLnksXG4gICAgICB3aWR0aDogY2xpcHBpbmdBbmNlc3Rvci53aWR0aCxcbiAgICAgIGhlaWdodDogY2xpcHBpbmdBbmNlc3Rvci5oZWlnaHRcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0VG9DbGllbnRSZWN0KHJlY3QpO1xufVxuZnVuY3Rpb24gaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIHN0b3BOb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAocGFyZW50Tm9kZSA9PT0gc3RvcE5vZGUgfHwgIWlzRWxlbWVudChwYXJlbnROb2RlKSB8fCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUkMShwYXJlbnROb2RlKS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyB8fCBoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IocGFyZW50Tm9kZSwgc3RvcE5vZGUpO1xufVxuXG4vLyBBIFwiY2xpcHBpbmcgYW5jZXN0b3JcIiBpcyBhbiBgb3ZlcmZsb3dgIGVsZW1lbnQgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIGNoaWxkIGVsZW1lbnRzLiBUaGlzIHJldHVybnMgYWxsIGNsaXBwaW5nIGFuY2VzdG9yc1xuLy8gb2YgdGhlIGdpdmVuIGVsZW1lbnQgdXAgdGhlIHRyZWUuXG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCwgW10sIGZhbHNlKS5maWx0ZXIoZWwgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09ICdib2R5Jyk7XG4gIGxldCBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gIGNvbnN0IGVsZW1lbnRJc0ZpeGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnO1xuICBsZXQgY3VycmVudE5vZGUgPSBlbGVtZW50SXNGaXhlZCA/IGdldFBhcmVudE5vZGUoZWxlbWVudCkgOiBlbGVtZW50O1xuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXG4gIHdoaWxlIChpc0VsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUkMShjdXJyZW50Tm9kZSk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgaWYgKCFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZERyb3BDdXJyZW50Tm9kZSA9IGVsZW1lbnRJc0ZpeGVkID8gIWN1cnJlbnROb2RlSXNDb250YWluaW5nICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjdXJyZW50Tm9kZUlzQ29udGFpbmluZyAmJiBjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnc3RhdGljJyAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIGFic29sdXRlT3JGaXhlZC5oYXMoY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUucG9zaXRpb24pIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGVJc0NvbnRhaW5pbmcgJiYgaGFzRml4ZWRQb3NpdGlvbkFuY2VzdG9yKGVsZW1lbnQsIGN1cnJlbnROb2RlKTtcbiAgICBpZiAoc2hvdWxkRHJvcEN1cnJlbnROb2RlKSB7XG4gICAgICAvLyBEcm9wIG5vbi1jb250YWluaW5nIGJsb2Nrcy5cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoYW5jZXN0b3IgPT4gYW5jZXN0b3IgIT09IGN1cnJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVjb3JkIGxhc3QgY29udGFpbmluZyBibG9jayBmb3IgbmV4dCBpdGVyYXRpb24uXG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgY2FjaGUuc2V0KGVsZW1lbnQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2Zcbi8vIGNsaXBwaW5nIGFuY2VzdG9ycy5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChfcmVmKSB7XG4gIGxldCB7XG4gICAgZWxlbWVudCxcbiAgICBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnksXG4gICAgc3RyYXRlZ3lcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGVsZW1lbnRDbGlwcGluZ0FuY2VzdG9ycyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdBbmNlc3RvcnMnID8gaXNUb3BMYXllcihlbGVtZW50KSA/IFtdIDogZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIHRoaXMuX2MpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBbLi4uZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nQW5jZXN0b3IgPSBjbGlwcGluZ0FuY2VzdG9yc1swXTtcbiAgY29uc3QgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdBbmNlc3RvcnMucmVkdWNlKChhY2NSZWN0LCBjbGlwcGluZ0FuY2VzdG9yKSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcCxcbiAgICB4OiBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICB5OiBjbGlwcGluZ1JlY3QudG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSBnZXRDc3NEaW1lbnNpb25zKGVsZW1lbnQpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChlbGVtZW50LCBvZmZzZXRQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgaXNGaXhlZCA9IHN0cmF0ZWd5ID09PSAnZml4ZWQnO1xuICBjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHRydWUsIGlzRml4ZWQsIG9mZnNldFBhcmVudCk7XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgY29uc3Qgb2Zmc2V0cyA9IGNyZWF0ZUNvb3JkcygwKTtcblxuICAvLyBJZiB0aGUgPGJvZHk+IHNjcm9sbGJhciBhcHBlYXJzIG9uIHRoZSBsZWZ0IChlLmcuIFJUTCBzeXN0ZW1zKS4gVXNlXG4gIC8vIEZpcmVmb3ggd2l0aCBsYXlvdXQuc2Nyb2xsYmFyLnNpZGUgPSAzIGluIGFib3V0OmNvbmZpZyB0byB0ZXN0IHRoaXMuXG4gIGZ1bmN0aW9uIHNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQoKSB7XG4gICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICB9XG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IGlzT3ZlcmZsb3dFbGVtZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSwgaXNGaXhlZCwgb2Zmc2V0UGFyZW50KTtcbiAgICAgIG9mZnNldHMueCA9IG9mZnNldFJlY3QueCArIG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ID0gb2Zmc2V0UmVjdC55ICsgb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNGaXhlZCAmJiAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgc2V0TGVmdFJUTFNjcm9sbGJhck9mZnNldCgpO1xuICB9XG4gIGNvbnN0IGh0bWxPZmZzZXQgPSBkb2N1bWVudEVsZW1lbnQgJiYgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkID8gZ2V0SFRNTE9mZnNldChkb2N1bWVudEVsZW1lbnQsIHNjcm9sbCkgOiBjcmVhdGVDb29yZHMoMCk7XG4gIGNvbnN0IHggPSByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCAtIGh0bWxPZmZzZXQueDtcbiAgY29uc3QgeSA9IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSAtIGh0bWxPZmZzZXQueTtcbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc1N0YXRpY1Bvc2l0aW9uZWQoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJztcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHBvbHlmaWxsKSB7XG4gICAgcmV0dXJuIHBvbHlmaWxsKGVsZW1lbnQpO1xuICB9XG4gIGxldCByYXdPZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAvLyBGaXJlZm94IHJldHVybnMgdGhlIDxodG1sPiBlbGVtZW50IGFzIHRoZSBvZmZzZXRQYXJlbnQgaWYgaXQncyBub24tc3RhdGljLFxuICAvLyB3aGlsZSBDaHJvbWUgYW5kIFNhZmFyaSByZXR1cm4gdGhlIDxib2R5PiBlbGVtZW50LiBUaGUgPGJvZHk+IGVsZW1lbnQgbXVzdFxuICAvLyBiZSB1c2VkIHRvIHBlcmZvcm0gdGhlIGNvcnJlY3QgY2FsY3VsYXRpb25zIGV2ZW4gaWYgdGhlIDxodG1sPiBlbGVtZW50IGlzXG4gIC8vIG5vbi1zdGF0aWMuXG4gIGlmIChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgPT09IHJhd09mZnNldFBhcmVudCkge1xuICAgIHJhd09mZnNldFBhcmVudCA9IHJhd09mZnNldFBhcmVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cbiAgcmV0dXJuIHJhd09mZnNldFBhcmVudDtcbn1cblxuLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuLy8gc3VjaCBhcyB0YWJsZSBhbmNlc3RvcnMgYW5kIGNyb3NzIGJyb3dzZXIgYnVncy5cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50LCBwb2x5ZmlsbCkge1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGlmIChpc1RvcExheWVyKGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICBsZXQgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgICB3aGlsZSAoc3ZnT2Zmc2V0UGFyZW50ICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgaWYgKGlzRWxlbWVudChzdmdPZmZzZXRQYXJlbnQpICYmICFpc1N0YXRpY1Bvc2l0aW9uZWQoc3ZnT2Zmc2V0UGFyZW50KSkge1xuICAgICAgICByZXR1cm4gc3ZnT2Zmc2V0UGFyZW50O1xuICAgICAgfVxuICAgICAgc3ZnT2Zmc2V0UGFyZW50ID0gZ2V0UGFyZW50Tm9kZShzdmdPZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luO1xuICB9XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQsIHBvbHlmaWxsKTtcbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQsIHBvbHlmaWxsKTtcbiAgfVxuICBpZiAob2Zmc2V0UGFyZW50ICYmIGlzTGFzdFRyYXZlcnNhYmxlTm9kZShvZmZzZXRQYXJlbnQpICYmIGlzU3RhdGljUG9zaXRpb25lZChvZmZzZXRQYXJlbnQpICYmICFpc0NvbnRhaW5pbmdCbG9jayhvZmZzZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIHdpbjtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW47XG59XG5cbmNvbnN0IGdldEVsZW1lbnRSZWN0cyA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhKSB7XG4gIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICBjb25zdCBnZXREaW1lbnNpb25zRm4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIGNvbnN0IGZsb2F0aW5nRGltZW5zaW9ucyA9IGF3YWl0IGdldERpbWVuc2lvbnNGbihkYXRhLmZsb2F0aW5nKTtcbiAgcmV0dXJuIHtcbiAgICByZWZlcmVuY2U6IGdldFJlY3RSZWxhdGl2ZVRvT2Zmc2V0UGFyZW50KGRhdGEucmVmZXJlbmNlLCBhd2FpdCBnZXRPZmZzZXRQYXJlbnRGbihkYXRhLmZsb2F0aW5nKSwgZGF0YS5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgd2lkdGg6IGZsb2F0aW5nRGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZmxvYXRpbmdEaW1lbnNpb25zLmhlaWdodFxuICAgIH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGlzUlRMKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldEVsZW1lbnRSZWN0cyxcbiAgZ2V0Q2xpZW50UmVjdHMsXG4gIGdldERpbWVuc2lvbnMsXG4gIGdldFNjYWxlLFxuICBpc0VsZW1lbnQsXG4gIGlzUlRMXG59O1xuXG5mdW5jdGlvbiByZWN0c0FyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEueCA9PT0gYi54ICYmIGEueSA9PT0gYi55ICYmIGEud2lkdGggPT09IGIud2lkdGggJiYgYS5oZWlnaHQgPT09IGIuaGVpZ2h0O1xufVxuXG4vLyBodHRwczovL3NhbXRob3IuYXUvMjAyMS9vYnNlcnZpbmctZG9tL1xuZnVuY3Rpb24gb2JzZXJ2ZU1vdmUoZWxlbWVudCwgb25Nb3ZlKSB7XG4gIGxldCBpbyA9IG51bGw7XG4gIGxldCB0aW1lb3V0SWQ7XG4gIGNvbnN0IHJvb3QgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgdmFyIF9pbztcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAoX2lvID0gaW8pID09IG51bGwgfHwgX2lvLmRpc2Nvbm5lY3QoKTtcbiAgICBpbyA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVmcmVzaChza2lwLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAoc2tpcCA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMTtcbiAgICB9XG4gICAgY2xlYW51cCgpO1xuICAgIGNvbnN0IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbiA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGVsZW1lbnRSZWN0Rm9yUm9vdE1hcmdpbjtcbiAgICBpZiAoIXNraXApIHtcbiAgICAgIG9uTW92ZSgpO1xuICAgIH1cbiAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5zZXRUb3AgPSBmbG9vcih0b3ApO1xuICAgIGNvbnN0IGluc2V0UmlnaHQgPSBmbG9vcihyb290LmNsaWVudFdpZHRoIC0gKGxlZnQgKyB3aWR0aCkpO1xuICAgIGNvbnN0IGluc2V0Qm90dG9tID0gZmxvb3Iocm9vdC5jbGllbnRIZWlnaHQgLSAodG9wICsgaGVpZ2h0KSk7XG4gICAgY29uc3QgaW5zZXRMZWZ0ID0gZmxvb3IobGVmdCk7XG4gICAgY29uc3Qgcm9vdE1hcmdpbiA9IC1pbnNldFRvcCArIFwicHggXCIgKyAtaW5zZXRSaWdodCArIFwicHggXCIgKyAtaW5zZXRCb3R0b20gKyBcInB4IFwiICsgLWluc2V0TGVmdCArIFwicHhcIjtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZDogbWF4KDAsIG1pbigxLCB0aHJlc2hvbGQpKSB8fCAxXG4gICAgfTtcbiAgICBsZXQgaXNGaXJzdFVwZGF0ZSA9IHRydWU7XG4gICAgZnVuY3Rpb24gaGFuZGxlT2JzZXJ2ZShlbnRyaWVzKSB7XG4gICAgICBjb25zdCByYXRpbyA9IGVudHJpZXNbMF0uaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICBpZiAocmF0aW8gIT09IHRocmVzaG9sZCkge1xuICAgICAgICBpZiAoIWlzRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gcmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmF0aW8pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGNsaXBwZWQsIHRoZSByYXRpbyBpcyAwLiBUaHJvdHRsZSB0aGUgcmVmcmVzaFxuICAgICAgICAgIC8vIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiB1cGRhdGVzLlxuICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVmcmVzaChmYWxzZSwgMWUtNyk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaChmYWxzZSwgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmF0aW8gPT09IDEgJiYgIXJlY3RzQXJlRXF1YWwoZWxlbWVudFJlY3RGb3JSb290TWFyZ2luLCBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSkge1xuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgZXZlbiB0aG91Z2ggdGhlIHJhdGlvIGlzIHJlcG9ydGVkIGFzIDEsIHRoZVxuICAgICAgICAvLyBlbGVtZW50IGlzIG5vdCBhY3R1YWxseSBmdWxseSB3aXRoaW4gdGhlIEludGVyc2VjdGlvbk9ic2VydmVyJ3Mgcm9vdFxuICAgICAgICAvLyBhcmVhIGFueW1vcmUuIFRoaXMgY2FuIGhhcHBlbiB1bmRlciBwZXJmb3JtYW5jZSBjb25zdHJhaW50cy4gVGhpcyBtYXlcbiAgICAgICAgLy8gYmUgYSBidWcgaW4gdGhlIGJyb3dzZXIncyBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbi4gVG9cbiAgICAgICAgLy8gd29yayBhcm91bmQgdGhpcywgd2UgY29tcGFyZSB0aGUgZWxlbWVudCdzIGJvdW5kaW5nIHJlY3Qgbm93IHdpdGhcbiAgICAgICAgLy8gd2hhdCBpdCB3YXMgYXQgdGhlIHRpbWUgd2UgY3JlYXRlZCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIuIElmIHRoZXlcbiAgICAgICAgLy8gYXJlIG5vdCBlcXVhbCB0aGVuIHRoZSBlbGVtZW50IG1vdmVkLCBzbyB3ZSByZWZyZXNoLlxuICAgICAgICByZWZyZXNoKCk7XG4gICAgICB9XG4gICAgICBpc0ZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gT2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCBhIGBkb2N1bWVudGAgYXMgdGhlIHJvb3QgYW5kIHdpbGwgdGhyb3cgYW5cbiAgICAvLyBlcnJvci5cbiAgICB0cnkge1xuICAgICAgaW8gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlT2JzZXJ2ZSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IHJvb3Qub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoX2UpIHtcbiAgICAgIGlvID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGhhbmRsZU9ic2VydmUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpby5vYnNlcnZlKGVsZW1lbnQpO1xuICB9XG4gIHJlZnJlc2godHJ1ZSk7XG4gIHJldHVybiBjbGVhbnVwO1xufVxuXG4vKipcbiAqIEF1dG9tYXRpY2FsbHkgdXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBuZWNlc3NhcnkuXG4gKiBTaG91bGQgb25seSBiZSBjYWxsZWQgd2hlbiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBtb3VudGVkIG9uIHRoZSBET00gb3JcbiAqIHZpc2libGUgb24gdGhlIHNjcmVlbi5cbiAqIEByZXR1cm5zIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgaW52b2tlZCB3aGVuIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzXG4gKiByZW1vdmVkIGZyb20gdGhlIERPTSBvciBoaWRkZW4gZnJvbSB0aGUgc2NyZWVuLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9VcGRhdGVcbiAqL1xuZnVuY3Rpb24gYXV0b1VwZGF0ZShyZWZlcmVuY2UsIGZsb2F0aW5nLCB1cGRhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGxheW91dFNoaWZ0ID0gdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSAnZnVuY3Rpb24nLFxuICAgIGFuaW1hdGlvbkZyYW1lID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gdW53cmFwRWxlbWVudChyZWZlcmVuY2UpO1xuICBjb25zdCBhbmNlc3RvcnMgPSBhbmNlc3RvclNjcm9sbCB8fCBhbmNlc3RvclJlc2l6ZSA/IFsuLi4ocmVmZXJlbmNlRWwgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhyZWZlcmVuY2VFbCkgOiBbXSksIC4uLmdldE92ZXJmbG93QW5jZXN0b3JzKGZsb2F0aW5nKV0gOiBbXTtcbiAgYW5jZXN0b3JzLmZvckVhY2goYW5jZXN0b3IgPT4ge1xuICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZSk7XG4gIH0pO1xuICBjb25zdCBjbGVhbnVwSW8gPSByZWZlcmVuY2VFbCAmJiBsYXlvdXRTaGlmdCA/IG9ic2VydmVNb3ZlKHJlZmVyZW5jZUVsLCB1cGRhdGUpIDogbnVsbDtcbiAgbGV0IHJlb2JzZXJ2ZUZyYW1lID0gLTE7XG4gIGxldCByZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICBsZXQgW2ZpcnN0RW50cnldID0gX3JlZjtcbiAgICAgIGlmIChmaXJzdEVudHJ5ICYmIGZpcnN0RW50cnkudGFyZ2V0ID09PSByZWZlcmVuY2VFbCAmJiByZXNpemVPYnNlcnZlcikge1xuICAgICAgICAvLyBQcmV2ZW50IHVwZGF0ZSBsb29wcyB3aGVuIHVzaW5nIHRoZSBgc2l6ZWAgbWlkZGxld2FyZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzQwXG4gICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShmbG9hdGluZyk7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJlb2JzZXJ2ZUZyYW1lKTtcbiAgICAgICAgcmVvYnNlcnZlRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHZhciBfcmVzaXplT2JzZXJ2ZXI7XG4gICAgICAgICAgKF9yZXNpemVPYnNlcnZlciA9IHJlc2l6ZU9ic2VydmVyKSA9PSBudWxsIHx8IF9yZXNpemVPYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9KTtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgIWFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKHJlZmVyZW5jZUVsKTtcbiAgICB9XG4gICAgcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShmbG9hdGluZyk7XG4gIH1cbiAgbGV0IGZyYW1lSWQ7XG4gIGxldCBwcmV2UmVmUmVjdCA9IGFuaW1hdGlvbkZyYW1lID8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHJlZmVyZW5jZSkgOiBudWxsO1xuICBpZiAoYW5pbWF0aW9uRnJhbWUpIHtcbiAgICBmcmFtZUxvb3AoKTtcbiAgfVxuICBmdW5jdGlvbiBmcmFtZUxvb3AoKSB7XG4gICAgY29uc3QgbmV4dFJlZlJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKTtcbiAgICBpZiAocHJldlJlZlJlY3QgJiYgIXJlY3RzQXJlRXF1YWwocHJldlJlZlJlY3QsIG5leHRSZWZSZWN0KSkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgfVxuICAgIHByZXZSZWZSZWN0ID0gbmV4dFJlZlJlY3Q7XG4gICAgZnJhbWVJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmcmFtZUxvb3ApO1xuICB9XG4gIHVwZGF0ZSgpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBfcmVzaXplT2JzZXJ2ZXIyO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKGFuY2VzdG9yID0+IHtcbiAgICAgIGFuY2VzdG9yU2Nyb2xsICYmIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHVwZGF0ZSk7XG4gICAgICBhbmNlc3RvclJlc2l6ZSAmJiBhbmNlc3Rvci5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIGNsZWFudXBJbyA9PSBudWxsIHx8IGNsZWFudXBJbygpO1xuICAgIChfcmVzaXplT2JzZXJ2ZXIyID0gcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgfHwgX3Jlc2l6ZU9ic2VydmVyMi5kaXNjb25uZWN0KCk7XG4gICAgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IG9mIG92ZXJmbG93IHNpZGUgb2Zmc2V0cyB0aGF0IGRldGVybWluZSBob3cgbXVjaCB0aGVcbiAqIGVsZW1lbnQgaXMgb3ZlcmZsb3dpbmcgYSBnaXZlbiBjbGlwcGluZyBib3VuZGFyeSBvbiBlYWNoIHNpZGUuXG4gKiAtIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGJvdW5kYXJ5IGJ5IHRoYXQgbnVtYmVyIG9mIHBpeGVsc1xuICogLSBuZWdhdGl2ZSA9IGhvdyBtYW55IHBpeGVscyBsZWZ0IGJlZm9yZSBpdCB3aWxsIG92ZXJmbG93XG4gKiAtIDAgPSBsaWVzIGZsdXNoIHdpdGggdGhlIGJvdW5kYXJ5XG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZGV0ZWN0T3ZlcmZsb3dcbiAqL1xuY29uc3QgZGV0ZWN0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyQxO1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSBvZmZzZXQkMTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgY2hvb3NpbmcgdGhlIHBsYWNlbWVudFxuICogdGhhdCBoYXMgdGhlIG1vc3Qgc3BhY2UgYXZhaWxhYmxlIGF1dG9tYXRpY2FsbHksIHdpdGhvdXQgbmVlZGluZyB0byBzcGVjaWZ5IGFcbiAqIHByZWZlcnJlZCBwbGFjZW1lbnQuIEFsdGVybmF0aXZlIHRvIGBmbGlwYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hdXRvUGxhY2VtZW50XG4gKi9cbmNvbnN0IGF1dG9QbGFjZW1lbnQgPSBhdXRvUGxhY2VtZW50JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IHNoaWZ0JDE7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGZsaXBwaW5nIHRoZSBgcGxhY2VtZW50YFxuICogaW4gb3JkZXIgdG8ga2VlcCBpdCBpbiB2aWV3IHdoZW4gdGhlIHByZWZlcnJlZCBwbGFjZW1lbnQocykgd2lsbCBvdmVyZmxvdyB0aGVcbiAqIGNsaXBwaW5nIGJvdW5kYXJ5LiBBbHRlcm5hdGl2ZSB0byBgYXV0b1BsYWNlbWVudGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvZmxpcFxuICovXG5jb25zdCBmbGlwID0gZmxpcCQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSBzaXplJDE7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gaGlkZSQxO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IGFycm93JDE7XG5cbi8qKlxuICogUHJvdmlkZXMgaW1wcm92ZWQgcG9zaXRpb25pbmcgZm9yIGlubGluZSByZWZlcmVuY2UgZWxlbWVudHMgdGhhdCBjYW4gc3BhblxuICogb3ZlciBtdWx0aXBsZSBsaW5lcywgc3VjaCBhcyBoeXBlcmxpbmtzIG9yIHJhbmdlIHNlbGVjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5saW5lXG4gKi9cbmNvbnN0IGlubGluZSA9IGlubGluZSQxO1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gbGltaXRTaGlmdCQxO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyB0aGF0IHdpbGwgcGxhY2UgdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAqIG5leHQgdG8gYSBnaXZlbiByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgLy8gVGhpcyBjYWNoZXMgdGhlIGV4cGVuc2l2ZSBgZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzYCBmdW5jdGlvbiBzbyB0aGF0XG4gIC8vIG11bHRpcGxlIGxpZmVjeWNsZSByZXNldHMgcmUtdXNlIHRoZSBzYW1lIHJlc3VsdC4gSXQgb25seSBsaXZlcyBmb3IgYVxuICAvLyBzaW5nbGUgY2FsbC4gSWYgb3RoZXIgZnVuY3Rpb25zIGJlY29tZSBleHBlbnNpdmUsIHdlIGNhbiBhZGQgdGhlbSBhcyB3ZWxsLlxuICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHtcbiAgICBwbGF0Zm9ybSxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGNvbnN0IHBsYXRmb3JtV2l0aENhY2hlID0ge1xuICAgIC4uLm1lcmdlZE9wdGlvbnMucGxhdGZvcm0sXG4gICAgX2M6IGNhY2hlXG4gIH07XG4gIHJldHVybiBjb21wdXRlUG9zaXRpb24kMShyZWZlcmVuY2UsIGZsb2F0aW5nLCB7XG4gICAgLi4ubWVyZ2VkT3B0aW9ucyxcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm1XaXRoQ2FjaGVcbiAgfSk7XG59O1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHBsYXRmb3JtLCBzaGlmdCwgc2l6ZSB9O1xuIl0sIm5hbWVzIjpbInJlY3RUb0NsaWVudFJlY3QiLCJhcnJvdyIsImFycm93JDEiLCJhdXRvUGxhY2VtZW50IiwiYXV0b1BsYWNlbWVudCQxIiwiZGV0ZWN0T3ZlcmZsb3ciLCJkZXRlY3RPdmVyZmxvdyQxIiwiZmxpcCIsImZsaXAkMSIsImhpZGUiLCJoaWRlJDEiLCJpbmxpbmUiLCJpbmxpbmUkMSIsImxpbWl0U2hpZnQiLCJsaW1pdFNoaWZ0JDEiLCJvZmZzZXQiLCJvZmZzZXQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsInNpemUiLCJzaXplJDEiLCJjb21wdXRlUG9zaXRpb24iLCJjb21wdXRlUG9zaXRpb24kMSIsInJvdW5kIiwiY3JlYXRlQ29vcmRzIiwibWF4IiwibWluIiwiZmxvb3IiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZSQxIiwiaXNIVE1MRWxlbWVudCIsImlzRWxlbWVudCIsImdldFdpbmRvdyIsImlzV2ViS2l0IiwiZ2V0RnJhbWVFbGVtZW50IiwiZ2V0Tm9kZVNjcm9sbCIsImdldERvY3VtZW50RWxlbWVudCIsImlzVG9wTGF5ZXIiLCJnZXROb2RlTmFtZSIsImlzT3ZlcmZsb3dFbGVtZW50IiwiZ2V0T3ZlcmZsb3dBbmNlc3RvcnMiLCJnZXRQYXJlbnROb2RlIiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiaXNDb250YWluaW5nQmxvY2siLCJpc1RhYmxlRWxlbWVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImdldENzc0RpbWVuc2lvbnMiLCJlbGVtZW50IiwiY3NzIiwid2lkdGgiLCJwYXJzZUZsb2F0IiwiaGVpZ2h0IiwiaGFzT2Zmc2V0Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzaG91bGRGYWxsYmFjayIsIiQiLCJ1bndyYXBFbGVtZW50IiwiY29udGV4dEVsZW1lbnQiLCJnZXRTY2FsZSIsImRvbUVsZW1lbnQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwieCIsInkiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm5vT2Zmc2V0cyIsImdldFZpc3VhbE9mZnNldHMiLCJ3aW4iLCJ2aXN1YWxWaWV3cG9ydCIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJzaG91bGRBZGRWaXN1YWxPZmZzZXRzIiwiaXNGaXhlZCIsImZsb2F0aW5nT2Zmc2V0UGFyZW50IiwiaW5jbHVkZVNjYWxlIiwiaXNGaXhlZFN0cmF0ZWd5Iiwib2Zmc2V0UGFyZW50IiwiY2xpZW50UmVjdCIsInNjYWxlIiwidmlzdWFsT2Zmc2V0cyIsImxlZnQiLCJ0b3AiLCJvZmZzZXRXaW4iLCJjdXJyZW50V2luIiwiY3VycmVudElGcmFtZSIsImlmcmFtZVNjYWxlIiwiaWZyYW1lUmVjdCIsImNsaWVudExlZnQiLCJwYWRkaW5nTGVmdCIsImNsaWVudFRvcCIsInBhZGRpbmdUb3AiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwibGVmdFNjcm9sbCIsInNjcm9sbExlZnQiLCJnZXRIVE1MT2Zmc2V0IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsIiwiaHRtbFJlY3QiLCJzY3JvbGxUb3AiLCJjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCIsIl9yZWYiLCJlbGVtZW50cyIsInN0cmF0ZWd5IiwidG9wTGF5ZXIiLCJmbG9hdGluZyIsIm9mZnNldHMiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFJlY3QiLCJodG1sT2Zmc2V0IiwiZ2V0Q2xpZW50UmVjdHMiLCJBcnJheSIsImZyb20iLCJnZXREb2N1bWVudFJlY3QiLCJodG1sIiwiYm9keSIsIm93bmVyRG9jdW1lbnQiLCJzY3JvbGxXaWR0aCIsImNsaWVudFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZGlyZWN0aW9uIiwiU0NST0xMQkFSX01BWCIsImdldFZpZXdwb3J0UmVjdCIsInZpc3VhbFZpZXdwb3J0QmFzZWQiLCJ3aW5kb3dTY3JvbGxiYXJYIiwiZG9jIiwiYm9keVN0eWxlcyIsImJvZHlNYXJnaW5JbmxpbmUiLCJjb21wYXRNb2RlIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwiY2xpcHBpbmdTdGFibGVTY3JvbGxiYXJXaWR0aCIsIk1hdGgiLCJhYnMiLCJhYnNvbHV0ZU9yRml4ZWQiLCJTZXQiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvciIsImNsaXBwaW5nQW5jZXN0b3IiLCJoYXNGaXhlZFBvc2l0aW9uQW5jZXN0b3IiLCJzdG9wTm9kZSIsInBhcmVudE5vZGUiLCJwb3NpdGlvbiIsImdldENsaXBwaW5nRWxlbWVudEFuY2VzdG9ycyIsImNhY2hlIiwiY2FjaGVkUmVzdWx0IiwiZ2V0IiwicmVzdWx0IiwiZmlsdGVyIiwiZWwiLCJjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSIsImVsZW1lbnRJc0ZpeGVkIiwiY3VycmVudE5vZGUiLCJjb21wdXRlZFN0eWxlIiwiY3VycmVudE5vZGVJc0NvbnRhaW5pbmciLCJzaG91bGREcm9wQ3VycmVudE5vZGUiLCJoYXMiLCJhbmNlc3RvciIsInNldCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwiZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzIiwiX2MiLCJjb25jYXQiLCJjbGlwcGluZ0FuY2VzdG9ycyIsImZpcnN0Q2xpcHBpbmdBbmNlc3RvciIsImNsaXBwaW5nUmVjdCIsInJlZHVjZSIsImFjY1JlY3QiLCJyaWdodCIsImJvdHRvbSIsImdldERpbWVuc2lvbnMiLCJnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudCIsInNldExlZnRSVExTY3JvbGxiYXJPZmZzZXQiLCJpc1N0YXRpY1Bvc2l0aW9uZWQiLCJnZXRUcnVlT2Zmc2V0UGFyZW50IiwicG9seWZpbGwiLCJyYXdPZmZzZXRQYXJlbnQiLCJnZXRPZmZzZXRQYXJlbnQiLCJzdmdPZmZzZXRQYXJlbnQiLCJnZXRFbGVtZW50UmVjdHMiLCJkYXRhIiwiZ2V0T2Zmc2V0UGFyZW50Rm4iLCJnZXREaW1lbnNpb25zRm4iLCJmbG9hdGluZ0RpbWVuc2lvbnMiLCJyZWZlcmVuY2UiLCJpc1JUTCIsInBsYXRmb3JtIiwicmVjdHNBcmVFcXVhbCIsImEiLCJiIiwib2JzZXJ2ZU1vdmUiLCJvbk1vdmUiLCJpbyIsInRpbWVvdXRJZCIsInJvb3QiLCJjbGVhbnVwIiwiX2lvIiwiY2xlYXJUaW1lb3V0IiwiZGlzY29ubmVjdCIsInJlZnJlc2giLCJza2lwIiwidGhyZXNob2xkIiwiZWxlbWVudFJlY3RGb3JSb290TWFyZ2luIiwiaW5zZXRUb3AiLCJpbnNldFJpZ2h0IiwiaW5zZXRCb3R0b20iLCJpbnNldExlZnQiLCJyb290TWFyZ2luIiwib3B0aW9ucyIsImlzRmlyc3RVcGRhdGUiLCJoYW5kbGVPYnNlcnZlIiwiZW50cmllcyIsInJhdGlvIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJzZXRUaW1lb3V0IiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJfZSIsIm9ic2VydmUiLCJhdXRvVXBkYXRlIiwidXBkYXRlIiwiYW5jZXN0b3JTY3JvbGwiLCJhbmNlc3RvclJlc2l6ZSIsImVsZW1lbnRSZXNpemUiLCJSZXNpemVPYnNlcnZlciIsImxheW91dFNoaWZ0IiwiYW5pbWF0aW9uRnJhbWUiLCJyZWZlcmVuY2VFbCIsImFuY2VzdG9ycyIsImZvckVhY2giLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImNsZWFudXBJbyIsInJlb2JzZXJ2ZUZyYW1lIiwicmVzaXplT2JzZXJ2ZXIiLCJmaXJzdEVudHJ5IiwidGFyZ2V0IiwidW5vYnNlcnZlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJfcmVzaXplT2JzZXJ2ZXIiLCJmcmFtZUlkIiwicHJldlJlZlJlY3QiLCJmcmFtZUxvb3AiLCJuZXh0UmVmUmVjdCIsIl9yZXNpemVPYnNlcnZlcjIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiTWFwIiwibWVyZ2VkT3B0aW9ucyIsInBsYXRmb3JtV2l0aENhY2hlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\nvar isClient = typeof document !== 'undefined';\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\nfunction getDPR(element) {\n  if (true) {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\nfunction useLatestRef(value) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)(options),\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift)(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2TztBQUM5SDtBQUNoRjtBQUNTO0FBQ0Y7QUFFdEMsSUFBSTBCLFFBQVEsR0FBRyxPQUFPQyxRQUFRLEtBQUssV0FBVztBQUU5QyxJQUFJQyxJQUFJLEdBQUcsU0FBU0EsSUFBSUEsQ0FBQSxFQUFHLENBQUMsQ0FBQztBQUM3QixJQUFJQyxLQUFLLEdBQUdILFFBQVEsR0FBR0Ysa0RBQWUsR0FBR0ksSUFBSTs7QUFFN0M7QUFDQTtBQUNBLFNBQVNFLFNBQVNBLENBQUNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO0VBQ3ZCLElBQUlELENBQUMsS0FBS0MsQ0FBQyxFQUFFO0lBQ1gsT0FBTyxJQUFJO0VBQ2I7RUFDQSxJQUFJLE9BQU9ELENBQUMsS0FBSyxPQUFPQyxDQUFDLEVBQUU7SUFDekIsT0FBTyxLQUFLO0VBQ2Q7RUFDQSxJQUFJLE9BQU9ELENBQUMsS0FBSyxVQUFVLElBQUlBLENBQUMsQ0FBQ0UsUUFBUSxDQUFDLENBQUMsS0FBS0QsQ0FBQyxDQUFDQyxRQUFRLENBQUMsQ0FBQyxFQUFFO0lBQzVELE9BQU8sSUFBSTtFQUNiO0VBQ0EsSUFBSUMsTUFBTTtFQUNWLElBQUlDLENBQUM7RUFDTCxJQUFJQyxJQUFJO0VBQ1IsSUFBSUwsQ0FBQyxJQUFJQyxDQUFDLElBQUksT0FBT0QsQ0FBQyxLQUFLLFFBQVEsRUFBRTtJQUNuQyxJQUFJTSxLQUFLLENBQUNDLE9BQU8sQ0FBQ1AsQ0FBQyxDQUFDLEVBQUU7TUFDcEJHLE1BQU0sR0FBR0gsQ0FBQyxDQUFDRyxNQUFNO01BQ2pCLElBQUlBLE1BQU0sS0FBS0YsQ0FBQyxDQUFDRSxNQUFNLEVBQUUsT0FBTyxLQUFLO01BQ3JDLEtBQUtDLENBQUMsR0FBR0QsTUFBTSxFQUFFQyxDQUFDLEVBQUUsS0FBSyxDQUFDLEdB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QUM7RUFDbkJBLE9BQU8sRUFBRSxDQUFDQSxPQUFPLEVBQUUwRCxJQUFJO0FBQ3pCLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3Bvcy1zeXN0ZW0vLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0LWRvbS9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LWRvbS5tanM/Yzc5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjb21wdXRlUG9zaXRpb24sIGFycm93IGFzIGFycm93JDIsIGF1dG9QbGFjZW1lbnQgYXMgYXV0b1BsYWNlbWVudCQxLCBmbGlwIGFzIGZsaXAkMSwgaGlkZSBhcyBoaWRlJDEsIGlubGluZSBhcyBpbmxpbmUkMSwgbGltaXRTaGlmdCBhcyBsaW1pdFNoaWZ0JDEsIG9mZnNldCBhcyBvZmZzZXQkMSwgc2hpZnQgYXMgc2hpZnQkMSwgc2l6ZSBhcyBzaXplJDEgfSBmcm9tICdAZmxvYXRpbmctdWkvZG9tJztcbmV4cG9ydCB7IGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGdldE92ZXJmbG93QW5jZXN0b3JzLCBwbGF0Zm9ybSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcblxudmFyIGlzQ2xpZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgaW5kZXggPSBpc0NsaWVudCA/IHVzZUxheW91dEVmZmVjdCA6IG5vb3A7XG5cbi8vIEZvcmsgb2YgYGZhc3QtZGVlcC1lcXVhbGAgdGhhdCBvbmx5IGRvZXMgdGhlIGNvbXBhcmlzb25zIHdlIG5lZWQgYW5kIGNvbXBhcmVzXG4vLyBmdW5jdGlvbnNcbmZ1bmN0aW9uIGRlZXBFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhICE9PSB0eXBlb2YgYikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgPT09ICdmdW5jdGlvbicgJiYgYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBsZXQgbGVuZ3RoO1xuICBsZXQgaTtcbiAgbGV0IGtleXM7XG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgICBpZiAoIWRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICBpZiAoIXt9Lmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoa2V5ID09PSAnX293bmVyJyAmJiBhLiQkdHlwZW9mKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbn1cblxuZnVuY3Rpb24gZ2V0RFBSKGVsZW1lbnQpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgY29uc3Qgd2luID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuIHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQnlEUFIoZWxlbWVudCwgdmFsdWUpIHtcbiAgY29uc3QgZHByID0gZ2V0RFBSKGVsZW1lbnQpO1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIGRwcikgLyBkcHI7XG59XG5cbmZ1bmN0aW9uIHVzZUxhdGVzdFJlZih2YWx1ZSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYodmFsdWUpO1xuICBpbmRleCgoKSA9PiB7XG4gICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZWY7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBwbGFjZW1lbnQgPSAnYm90dG9tJyxcbiAgICBzdHJhdGVneSA9ICdhYnNvbHV0ZScsXG4gICAgbWlkZGxld2FyZSA9IFtdLFxuICAgIHBsYXRmb3JtLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IGV4dGVybmFsUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmc6IGV4dGVybmFsRmxvYXRpbmdcbiAgICB9ID0ge30sXG4gICAgdHJhbnNmb3JtID0gdHJ1ZSxcbiAgICB3aGlsZUVsZW1lbnRzTW91bnRlZCxcbiAgICBvcGVuXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0cmF0ZWd5LFxuICAgIHBsYWNlbWVudCxcbiAgICBtaWRkbGV3YXJlRGF0YToge30sXG4gICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICB9KTtcbiAgY29uc3QgW2xhdGVzdE1pZGRsZXdhcmUsIHNldExhdGVzdE1pZGRsZXdhcmVdID0gUmVhY3QudXNlU3RhdGUobWlkZGxld2FyZSk7XG4gIGlmICghZGVlcEVxdWFsKGxhdGVzdE1pZGRsZXdhcmUsIG1pZGRsZXdhcmUpKSB7XG4gICAgc2V0TGF0ZXN0TWlkZGxld2FyZShtaWRkbGV3YXJlKTtcbiAgfVxuICBjb25zdCBbX3JlZmVyZW5jZSwgX3NldFJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW19mbG9hdGluZywgX3NldEZsb2F0aW5nXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBzZXRSZWZlcmVuY2UgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gcmVmZXJlbmNlUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgIF9zZXRSZWZlcmVuY2Uobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHNldEZsb2F0aW5nID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgaWYgKG5vZGUgIT09IGZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldEZsb2F0aW5nKG5vZGUpO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCByZWZlcmVuY2VFbCA9IGV4dGVybmFsUmVmZXJlbmNlIHx8IF9yZWZlcmVuY2U7XG4gIGNvbnN0IGZsb2F0aW5nRWwgPSBleHRlcm5hbEZsb2F0aW5nIHx8IF9mbG9hdGluZztcbiAgY29uc3QgcmVmZXJlbmNlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmbG9hdGluZ1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgZGF0YVJlZiA9IFJlYWN0LnVzZVJlZihkYXRhKTtcbiAgY29uc3QgaGFzV2hpbGVFbGVtZW50c01vdW50ZWQgPSB3aGlsZUVsZW1lbnRzTW91bnRlZCAhPSBudWxsO1xuICBjb25zdCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiA9IHVzZUxhdGVzdFJlZih3aGlsZUVsZW1lbnRzTW91bnRlZCk7XG4gIGNvbnN0IHBsYXRmb3JtUmVmID0gdXNlTGF0ZXN0UmVmKHBsYXRmb3JtKTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZihvcGVuKTtcbiAgY29uc3QgdXBkYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghcmVmZXJlbmNlUmVmLmN1cnJlbnQgfHwgIWZsb2F0aW5nUmVmLmN1cnJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgc3RyYXRlZ3ksXG4gICAgICBtaWRkbGV3YXJlOiBsYXRlc3RNaWRkbGV3YXJlXG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm1SZWYuY3VycmVudCkge1xuICAgICAgY29uZmlnLnBsYXRmb3JtID0gcGxhdGZvcm1SZWYuY3VycmVudDtcbiAgICB9XG4gICAgY29tcHV0ZVBvc2l0aW9uKHJlZmVyZW5jZVJlZi5jdXJyZW50LCBmbG9hdGluZ1JlZi5jdXJyZW50LCBjb25maWcpLnRoZW4oZGF0YSA9PiB7XG4gICAgICBjb25zdCBmdWxsRGF0YSA9IHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgLy8gVGhlIGZsb2F0aW5nIGVsZW1lbnQncyBwb3NpdGlvbiBtYXkgYmUgcmVjb21wdXRlZCB3aGlsZSBpdCdzIGNsb3NlZFxuICAgICAgICAvLyBidXQgc3RpbGwgbW91bnRlZCAoc3VjaCBhcyB3aGVuIHRyYW5zaXRpb25pbmcgb3V0KS4gVG8gZW5zdXJlXG4gICAgICAgIC8vIGBpc1Bvc2l0aW9uZWRgIHdpbGwgYmUgYGZhbHNlYCBpbml0aWFsbHkgb24gdGhlIG5leHQgb3BlbiwgYXZvaWRcbiAgICAgICAgLy8gc2V0dGluZyBpdCB0byBgdHJ1ZWAgd2hlbiBgb3BlbiA9PT0gZmFsc2VgIChtdXN0IGJlIHNwZWNpZmllZCkuXG4gICAgICAgIGlzUG9zaXRpb25lZDogb3BlblJlZi5jdXJyZW50ICE9PSBmYWxzZVxuICAgICAgfTtcbiAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCAmJiAhZGVlcEVxdWFsKGRhdGFSZWYuY3VycmVudCwgZnVsbERhdGEpKSB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudCA9IGZ1bGxEYXRhO1xuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldERhdGEoZnVsbERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2xhdGVzdE1pZGRsZXdhcmUsIHBsYWNlbWVudCwgc3RyYXRlZ3ksIHBsYXRmb3JtUmVmLCBvcGVuUmVmXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAob3BlbiA9PT0gZmFsc2UgJiYgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCkge1xuICAgICAgZGF0YVJlZi5jdXJyZW50LmlzUG9zaXRpb25lZCA9IGZhbHNlO1xuICAgICAgc2V0RGF0YShkYXRhID0+ICh7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlzUG9zaXRpb25lZDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIGNvbnN0IGlzTW91bnRlZFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpc01vdW50ZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICBpbmRleCgoKSA9PiB7XG4gICAgaWYgKHJlZmVyZW5jZUVsKSByZWZlcmVuY2VSZWYuY3VycmVudCA9IHJlZmVyZW5jZUVsO1xuICAgIGlmIChmbG9hdGluZ0VsKSBmbG9hdGluZ1JlZi5jdXJyZW50ID0gZmxvYXRpbmdFbDtcbiAgICBpZiAocmVmZXJlbmNlRWwgJiYgZmxvYXRpbmdFbCkge1xuICAgICAgaWYgKHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLmN1cnJlbnQocmVmZXJlbmNlRWwsIGZsb2F0aW5nRWwsIHVwZGF0ZSk7XG4gICAgICB9XG4gICAgICB1cGRhdGUoKTtcbiAgICB9XG4gIH0sIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlLCB3aGlsZUVsZW1lbnRzTW91bnRlZFJlZiwgaGFzV2hpbGVFbGVtZW50c01vdW50ZWRdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZVJlZixcbiAgICBmbG9hdGluZzogZmxvYXRpbmdSZWYsXG4gICAgc2V0UmVmZXJlbmNlLFxuICAgIHNldEZsb2F0aW5nXG4gIH0pLCBbc2V0UmVmZXJlbmNlLCBzZXRGbG9hdGluZ10pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUVsLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ0VsXG4gIH0pLCBbcmVmZXJlbmNlRWwsIGZsb2F0aW5nRWxdKTtcbiAgY29uc3QgZmxvYXRpbmdTdHlsZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMFxuICAgIH07XG4gICAgaWYgKCFlbGVtZW50cy5mbG9hdGluZykge1xuICAgICAgcmV0dXJuIGluaXRpYWxTdHlsZXM7XG4gICAgfVxuICAgIGNvbnN0IHggPSByb3VuZEJ5RFBSKGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLngpO1xuICAgIGNvbnN0IHkgPSByb3VuZEJ5RFBSKGVsZW1lbnRzLmZsb2F0aW5nLCBkYXRhLnkpO1xuICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmluaXRpYWxTdHlsZXMsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIixcbiAgICAgICAgLi4uKGdldERQUihlbGVtZW50cy5mbG9hdGluZykgPj0gMS41ICYmIHtcbiAgICAgICAgICB3aWxsQ2hhbmdlOiAndHJhbnNmb3JtJ1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBzdHJhdGVneSxcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB0b3A6IHlcbiAgICB9O1xuICB9LCBbc3RyYXRlZ3ksIHRyYW5zZm9ybSwgZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCwgZGF0YS55XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4uZGF0YSxcbiAgICB1cGRhdGUsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBmbG9hdGluZ1N0eWxlc1xuICB9KSwgW2RhdGEsIHVwZGF0ZSwgcmVmcywgZWxlbWVudHMsIGZsb2F0aW5nU3R5bGVzXSk7XG59XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyQxID0gb3B0aW9ucyA9PiB7XG4gIGZ1bmN0aW9uIGlzUmVmKHZhbHVlKSB7XG4gICAgcmV0dXJuIHt9Lmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjdXJyZW50Jyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnYXJyb3cnLFxuICAgIG9wdGlvbnMsXG4gICAgZm4oc3RhdGUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgcGFkZGluZ1xuICAgICAgfSA9IHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucyhzdGF0ZSkgOiBvcHRpb25zO1xuICAgICAgaWYgKGVsZW1lbnQgJiYgaXNSZWYoZWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY3VycmVudCAhPSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIGFycm93JDIoe1xuICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudC5jdXJyZW50LFxuICAgICAgICAgICAgcGFkZGluZ1xuICAgICAgICAgIH0pLmZuKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gYXJyb3ckMih7XG4gICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICBwYWRkaW5nXG4gICAgICAgIH0pLmZuKHN0YXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gIH07XG59O1xuXG4vKipcbiAqIE1vZGlmaWVzIHRoZSBwbGFjZW1lbnQgYnkgdHJhbnNsYXRpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYWxvbmcgdGhlXG4gKiBzcGVjaWZpZWQgYXhlcy5cbiAqIEEgbnVtYmVyIChzaG9ydGhhbmQgZm9yIGBtYWluQXhpc2Agb3IgZGlzdGFuY2UpLCBvciBhbiBheGVzIGNvbmZpZ3VyYXRpb25cbiAqIG9iamVjdCBtYXkgYmUgcGFzc2VkLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL29mZnNldFxuICovXG5jb25zdCBvZmZzZXQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4ub2Zmc2V0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IHNoaWZ0aW5nIGl0IGluIG9yZGVyIHRvXG4gKiBrZWVwIGl0IGluIHZpZXcgd2hlbiBpdCB3aWxsIG92ZXJmbG93IHRoZSBjbGlwcGluZyBib3VuZGFyeS5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaGlmdFxuICovXG5jb25zdCBzaGlmdCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIEJ1aWx0LWluIGBsaW1pdGVyYCB0aGF0IHdpbGwgc3RvcCBgc2hpZnQoKWAgYXQgYSBjZXJ0YWluIHBvaW50LlxuICovXG5jb25zdCBsaW1pdFNoaWZ0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmxpbWl0U2hpZnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgZmxpcHBpbmcgdGhlIGBwbGFjZW1lbnRgXG4gKiBpbiBvcmRlciB0byBrZWVwIGl0IGluIHZpZXcgd2hlbiB0aGUgcHJlZmVycmVkIHBsYWNlbWVudChzKSB3aWxsIG92ZXJmbG93IHRoZVxuICogY2xpcHBpbmcgYm91bmRhcnkuIEFsdGVybmF0aXZlIHRvIGBhdXRvUGxhY2VtZW50YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9mbGlwXG4gKi9cbmNvbnN0IGZsaXAgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uZmxpcCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdGhhdCBhbGxvd3MgeW91IHRvIGNoYW5nZSB0aGUgc2l6ZSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCDigJRcbiAqIGZvciBpbnN0YW5jZSwgcHJldmVudCBpdCBmcm9tIG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyBib3VuZGFyeSBvciBtYXRjaCB0aGVcbiAqIHdpZHRoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9zaXplXG4gKi9cbmNvbnN0IHNpemUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uc2l6ZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBjaG9vc2luZyB0aGUgcGxhY2VtZW50XG4gKiB0aGF0IGhhcyB0aGUgbW9zdCBzcGFjZSBhdmFpbGFibGUgYXV0b21hdGljYWxseSwgd2l0aG91dCBuZWVkaW5nIHRvIHNwZWNpZnkgYVxuICogcHJlZmVycmVkIHBsYWNlbWVudC4gQWx0ZXJuYXRpdmUgdG8gYGZsaXBgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2F1dG9QbGFjZW1lbnRcbiAqL1xuY29uc3QgYXV0b1BsYWNlbWVudCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5hdXRvUGxhY2VtZW50JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBoaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50IGluIGFwcGxpY2FibGUgc2l0dWF0aW9ucywgc3VjaCBhc1xuICogd2hlbiBpdCBpcyBub3QgaW4gdGhlIHNhbWUgY2xpcHBpbmcgY29udGV4dCBhcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaGlkZVxuICovXG5jb25zdCBoaWRlID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmhpZGUkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBpbXByb3ZlZCBwb3NpdGlvbmluZyBmb3IgaW5saW5lIHJlZmVyZW5jZSBlbGVtZW50cyB0aGF0IGNhbiBzcGFuXG4gKiBvdmVyIG11bHRpcGxlIGxpbmVzLCBzdWNoIGFzIGh5cGVybGlua3Mgb3IgcmFuZ2Ugc2VsZWN0aW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9pbmxpbmVcbiAqL1xuY29uc3QgaW5saW5lID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmlubGluZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYW4gaW5uZXIgZWxlbWVudCBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBzbyB0aGF0IGl0XG4gKiBhcHBlYXJzIGNlbnRlcmVkIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIFRoaXMgd3JhcHMgdGhlIGNvcmUgYGFycm93YCBtaWRkbGV3YXJlIHRvIGFsbG93IFJlYWN0IHJlZnMgYXMgdGhlIGVsZW1lbnQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXJyb3dcbiAqL1xuY29uc3QgYXJyb3cgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uYXJyb3ckMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGZsaXAsIGhpZGUsIGlubGluZSwgbGltaXRTaGlmdCwgb2Zmc2V0LCBzaGlmdCwgc2l6ZSwgdXNlRmxvYXRpbmcgfTtcbiJdLCJuYW1lcyI6WyJjb21wdXRlUG9zaXRpb24iLCJhcnJvdyIsImFycm93JDIiLCJhdXRvUGxhY2VtZW50IiwiYXV0b1BsYWNlbWVudCQxIiwiZmxpcCIsImZsaXAkMSIsImhpZGUiLCJoaWRlJDEiLCJpbmxpbmUiLCJpbmxpbmUkMSIsImxpbWl0U2hpZnQiLCJsaW1pdFNoaWZ0JDEiLCJvZmZzZXQiLCJvZmZzZXQkMSIsInNoaWZ0Iiwic2hpZnQkMSIsInNpemUiLCJzaXplJDEiLCJhdXRvVXBkYXRlIiwiZGV0ZWN0T3ZlcmZsb3ciLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsInBsYXRmb3JtIiwiUmVhY3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJSZWFjdERPTSIsImlzQ2xpZW50IiwiZG9jdW1lbnQiLCJub29wIiwiaW5kZXgiLCJkZWVwRXF1YWwiLCJhIiwiYiIsInRvU3RyaW5nIiwibGVuZ3RoIiwiaSIsImtleXMiLCJBcnJheSIsImlzQXJyYXkiLCJPYmplY3QiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJrZXkiLCIkJHR5cGVvZiIsImdldERQUiIsImVsZW1lbnQiLCJ3aW4iLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJkZXZpY2VQaXhlbFJhdGlvIiwicm91bmRCeURQUiIsInZhbHVlIiwiZHByIiwiTWF0aCIsInJvdW5kIiwidXNlTGF0ZXN0UmVmIiwicmVmIiwidXNlUmVmIiwiY3VycmVudCIsInVzZUZsb2F0aW5nIiwib3B0aW9ucyIsInBsYWNlbWVudCIsInN0cmF0ZWd5IiwibWlkZGxld2FyZSIsImVsZW1lbnRzIiwicmVmZXJlbmNlIiwiZXh0ZXJuYWxSZWZlcmVuY2UiLCJmbG9hdGluZyIsImV4dGVybmFsRmxvYXRpbmciLCJ0cmFuc2Zvcm0iLCJ3aGlsZUVsZW1lbnRzTW91bnRlZCIsIm9wZW4iLCJkYXRhIiwic2V0RGF0YSIsInVzZVN0YXRlIiwieCIsInkiLCJtaWRkbGV3YXJlRGF0YSIsImlzUG9zaXRpb25lZCIsImxhdGVzdE1pZGRsZXdhcmUiLCJzZXRMYXRlc3RNaWRkbGV3YXJlIiwiX3JlZmVyZW5jZSIsIl9zZXRSZWZlcmVuY2UiLCJfZmxvYXRpbmciLCJfc2V0RmxvYXRpbmciLCJzZXRSZWZlcmVuY2UiLCJ1c2VDYWxsYmFjayIsIm5vZGUiLCJyZWZlcmVuY2VSZWYiLCJzZXRGbG9hdGluZyIsImZsb2F0aW5nUmVmIiwicmVmZXJlbmNlRWwiLCJmbG9hdGluZ0VsIiwiZGF0YVJlZiIsImhhc1doaWxlRWxlbWVudHNNb3VudGVkIiwid2hpbGVFbGVtZW50c01vdW50ZWRSZWYiLCJwbGF0Zm9ybVJlZiIsIm9wZW5SZWYiLCJ1cGRhdGUiLCJjb25maWciLCJ0aGVuIiwiZnVsbERhdGEiLCJpc01vdW50ZWRSZWYiLCJmbHVzaFN5bmMiLCJyZWZzIiwidXNlTWVtbyIsImZsb2F0aW5nU3R5bGVzIiwiaW5pdGlhbFN0eWxlcyIsInBvc2l0aW9uIiwibGVmdCIsInRvcCIsIndpbGxDaGFuZ2UiLCJhcnJvdyQxIiwiaXNSZWYiLCJuYW1lIiwiZm4iLCJzdGF0ZSIsInBhZGRpbmciLCJkZXBzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getComputedStyle: () => (/* binding */ getComputedStyle),\n/* harmony export */   getContainingBlock: () => (/* binding */ getContainingBlock),\n/* harmony export */   getDocumentElement: () => (/* binding */ getDocumentElement),\n/* harmony export */   getFrameElement: () => (/* binding */ getFrameElement),\n/* harmony export */   getNearestOverflowAncestor: () => (/* binding */ getNearestOverflowAncestor),\n/* harmony export */   getNodeName: () => (/* binding */ getNodeName),\n/* harmony export */   getNodeScroll: () => (/* binding */ getNodeScroll),\n/* harmony export */   getOverflowAncestors: () => (/* binding */ getOverflowAncestors),\n/* harmony export */   getParentNode: () => (/* binding */ getParentNode),\n/* harmony export */   getWindow: () => (/* binding */ getWindow),\n/* harmony export */   isContainingBlock: () => (/* binding */ isContainingBlock),\n/* harmony export */   isElement: () => (/* binding */ isElement),\n/* harmony export */   isHTMLElement: () => (/* binding */ isHTMLElement),\n/* harmony export */   isLastTraversableNode: () => (/* binding */ isLastTraversableNode),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   isOverflowElement: () => (/* binding */ isOverflowElement),\n/* harmony export */   isShadowRoot: () => (/* binding */ isShadowRoot),\n/* harmony export */   isTableElement: () => (/* binding */ isTableElement),\n/* harmony export */   isTopLayer: () => (/* binding */ isTopLayer),\n/* harmony export */   isWebKit: () => (/* binding */ isWebKit)\n/* harmony export */ });\nfunction hasWindow() {\n  return false;\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nconst invalidOverflowDisplayValues = /*#__PURE__*/new Set(['inline', 'contents']);\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);\n}\nconst tableElements = /*#__PURE__*/new Set(['table', 'td', 'th']);\nfunction isTableElement(element) {\n  return tableElements.has(getNodeName(element));\n}\nconst topLayerSelectors = [':popover-open', ':modal'];\nfunction isTopLayer(element) {\n  return topLayerSelectors.some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (_e) {\n      return false;\n    }\n  });\n}\nconst transformProperties = ['transform', 'translate', 'scale', 'rotate', 'perspective'];\nconst willChangeValues = ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'];\nconst containValues = ['paint', 'layout', 'strict', 'content'];\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return transformProperties.some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || willChangeValues.some(value => (css.willChange || '').includes(value)) || containValues.some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nconst lastTraversableNodeNames = /*#__PURE__*/new Set(['html', 'body', '#document']);\nfunction isLastTraversableNode(node) {\n  return lastTraversableNodeNames.has(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMuZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLFNBQVNBLENBQUEsRUFBRztFQUNuQjtBQUNGO0FBQ0EsU0FBU0MsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFO0VBQ3pCLElBQUlDLE1BQU0sQ0FBQ0QsSUFBSSxDQUFDLEVBQUU7SUFDaEIsT0FBTyxDQUFDQSxJQUFJLENBQUNFLFFBQVEsSUFBSSxFQUFFLEVBQUVDLFdBQVcsQ0FBQyxDQUFDO0VBQzVDO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsT0FBTyxXQUFXO0FBQ3BCO0FBQ0EsU0FBU0MsU0FBU0EsQ0FBQ0osSUFBSSxFQUFFO0VBQ3ZCLElBQUlLLG1CQUFtQjtFQUN2QixPQUFPLENBQUNMLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQ0ssbUJBQW1CLEdBQUdMLElBQUksQ0FBQ00sYUFBYSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsbUJBQW1CLENBQUNFLFdBQVcsS0FBS0MsTUFBTTtBQUNsSTtBQUNBLFNBQVNDLGtCQUFrQkEsQ0FBQ1QsSUFBSSxFQUFFO0VBQ2hDLElBQUlVLElBQUk7RUFDUixPQUFPLENBQUNBLElBQUksR0FBRyxDQUFDVCxNQUFNLENBQUNELElBQUksQ0FBQyxHQUFHQSxJQUFJLENBQUNNLGFBQWEsR0FBR04sSUFBSSxDQUFDVyxRQUFRLEtBQUtILE1BQU0sQ0FBQ0csUUFBUSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUMsR0FBR0QsSUFBSSxDQUFDRSxlQUFlO0FBQ2hJO0FBQ0EsU0FBU1gsTUFBTUEsQ0FBQ1ksS0FBSyxFQUFFO0VBQ3JCLElBQUksQ0FBQ2YsU0FBUyxDQUFDLENBQUMsRUFBRTtJQUNoQixPQUFPLEtBQUs7RUFDZDtFQUNBLE9BQU9lLEtBQUssWUFBWUMsSUFBSSxJQUFJRCxLQUFLLFlBQVlULFNBQVMsQ0FB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RSxrQkFBa0IsQ0FBQztFQUN6QyxJQUFJQyxNQUFNLEVBQUU7SUFDVixNQUFNRSxZQUFZLEdBQUdDLGVBQWUsQ0FBQ0YsR0FBRyxDQUFDO0lBQ3pDLE9BQU9MLElBQUksQ0FBQ1EsTUFBTSxDQUFDSCxHQUFHLEVBQUVBLEdBQUcsQ0FBQ0ksY0FBYyxJQUFJLEVBQUUsRUFBRTNELGlCQUFpQixDQUFDcUQsa0JBQWtCLENBQUMsR0FBR0Esa0JBQWtCLEdBQUcsRUFBRSxFQUFFRyxZQUFZLElBQUlMLGVBQWUsR0FBR0Ysb0JBQW9CLENBQUNPLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQztFQUMvTDtFQUNBLE9BQU9OLElBQUksQ0FBQ1EsTUFBTSxDQUFDTCxrQkFBa0IsRUFBRUosb0JBQW9CLENBQUNJLGtCQUFrQixFQUFFLEVBQUUsRUFBRUYsZUFBZSxDQUFDLENBQUM7QUFDdkc7QUFDQSxTQUFTTSxlQUFlQSxDQUFDRixHQUFHLEVBQUU7RUFDNUIsT0FBT0EsR0FBRyxDQUFDSyxNQUFNLElBQUlDLE1BQU0sQ0FBQ0MsY0FBYyxDQUFDUCxHQUFHLENBQUNLLE1BQU0sQ0FBQyxHQUFHTCxHQUFHLENBQUNDLFlBQVksR0FBRyxJQUFJO0FBQ2xGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG9zLXN5c3RlbS8uL25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5kb20ubWpzPzI0ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gaGFzV2luZG93KCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBnZXROb2RlTmFtZShub2RlKSB7XG4gIGlmIChpc05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gKG5vZGUubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgLy8gTW9ja2VkIG5vZGVzIGluIHRlc3RpbmcgZW52aXJvbm1lbnRzIG1heSBub3QgYmUgaW5zdGFuY2VzIG9mIE5vZGUuIEJ5XG4gIC8vIHJldHVybmluZyBgI2RvY3VtZW50YCBhbiBpbmZpbml0ZSBsb29wIHdvbid0IG9jY3VyLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIzMTdcbiAgcmV0dXJuICcjZG9jdW1lbnQnO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgdmFyIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiAobm9kZSA9PSBudWxsIHx8IChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KG5vZGUpIHtcbiAgdmFyIF9yZWY7XG4gIHJldHVybiAoX3JlZiA9IChpc05vZGUobm9kZSkgPyBub2RlLm93bmVyRG9jdW1lbnQgOiBub2RlLmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfcmVmLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzTm9kZSh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLk5vZGU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgaWYgKCFoYXNXaW5kb3coKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5FbGVtZW50O1xufVxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdCh2YWx1ZSkge1xuICBpZiAoIWhhc1dpbmRvdygpIHx8IHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTaGFkb3dSb290IHx8IHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5TaGFkb3dSb290O1xufVxuY29uc3QgaW52YWxpZE92ZXJmbG93RGlzcGxheVZhbHVlcyA9IC8qI19fUFVSRV9fKi9uZXcgU2V0KFsnaW5saW5lJywgJ2NvbnRlbnRzJ10pO1xuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFpbnZhbGlkT3ZlcmZsb3dEaXNwbGF5VmFsdWVzLmhhcyhkaXNwbGF5KTtcbn1cbmNvbnN0IHRhYmxlRWxlbWVudHMgPSAvKiNfX1BVUkVfXyovbmV3IFNldChbJ3RhYmxlJywgJ3RkJywgJ3RoJ10pO1xuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gdGFibGVFbGVtZW50cy5oYXMoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpO1xufVxuY29uc3QgdG9wTGF5ZXJTZWxlY3RvcnMgPSBbJzpwb3BvdmVyLW9wZW4nLCAnOm1vZGFsJ107XG5mdW5jdGlvbiBpc1RvcExheWVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHRvcExheWVyU2VsZWN0b3JzLnNvbWUoc2VsZWN0b3IgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICB9IGNhdGNoIChfZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0aWVzID0gWyd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlJywgJ3NjYWxlJywgJ3JvdGF0ZScsICdwZXJzcGVjdGl2ZSddO1xuY29uc3Qgd2lsbENoYW5nZVZhbHVlcyA9IFsndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZScsICdzY2FsZScsICdyb3RhdGUnLCAncGVyc3BlY3RpdmUnLCAnZmlsdGVyJ107XG5jb25zdCBjb250YWluVmFsdWVzID0gWydwYWludCcsICdsYXlvdXQnLCAnc3RyaWN0JywgJ2NvbnRlbnQnXTtcbmZ1bmN0aW9uIGlzQ29udGFpbmluZ0Jsb2NrKGVsZW1lbnRPckNzcykge1xuICBjb25zdCB3ZWJraXQgPSBpc1dlYktpdCgpO1xuICBjb25zdCBjc3MgPSBpc0VsZW1lbnQoZWxlbWVudE9yQ3NzKSA/IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudE9yQ3NzKSA6IGVsZW1lbnRPckNzcztcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXRyYW5zZm9ybXMtMi8jaW5kaXZpZHVhbC10cmFuc2Zvcm1zXG4gIHJldHVybiB0cmFuc2Zvcm1Qcm9wZXJ0aWVzLnNvbWUodmFsdWUgPT4gY3NzW3ZhbHVlXSA/IGNzc1t2YWx1ZV0gIT09ICdub25lJyA6IGZhbHNlKSB8fCAoY3NzLmNvbnRhaW5lclR5cGUgPyBjc3MuY29udGFpbmVyVHlwZSAhPT0gJ25vcm1hbCcgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmJhY2tkcm9wRmlsdGVyID8gY3NzLmJhY2tkcm9wRmlsdGVyICE9PSAnbm9uZScgOiBmYWxzZSkgfHwgIXdlYmtpdCAmJiAoY3NzLmZpbHRlciA/IGNzcy5maWx0ZXIgIT09ICdub25lJyA6IGZhbHNlKSB8fCB3aWxsQ2hhbmdlVmFsdWVzLnNvbWUodmFsdWUgPT4gKGNzcy53aWxsQ2hhbmdlIHx8ICcnKS5pbmNsdWRlcyh2YWx1ZSkpIHx8IGNvbnRhaW5WYWx1ZXMuc29tZSh2YWx1ZSA9PiAoY3NzLmNvbnRhaW4gfHwgJycpLmluY2x1ZGVzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICBsZXQgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBpZiAoaXNDb250YWluaW5nQmxvY2soY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgfSBlbHNlIGlmIChpc1RvcExheWVyKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1dlYktpdCgpIHtcbiAgaWYgKHR5cGVvZiBDU1MgPT09ICd1bmRlZmluZWQnIHx8ICFDU1Muc3VwcG9ydHMpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIENTUy5zdXBwb3J0cygnLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXInLCAnbm9uZScpO1xufVxuY29uc3QgbGFzdFRyYXZlcnNhYmxlTm9kZU5hbWVzID0gLyojX19QVVJFX18qL25ldyBTZXQoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10pO1xuZnVuY3Rpb24gaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIGxhc3RUcmF2ZXJzYWJsZU5vZGVOYW1lcy5oYXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVTY3JvbGwoZWxlbWVudCkge1xuICBpZiAoaXNFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxYLFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxZXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKG5vZGUpIHtcbiAgaWYgKGdldE5vZGVOYW1lKG5vZGUpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPVxuICAvLyBTdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZS5cbiAgbm9kZS5hc3NpZ25lZFNsb3QgfHxcbiAgLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWQuXG4gIG5vZGUucGFyZW50Tm9kZSB8fFxuICAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICBpc1NoYWRvd1Jvb3Qobm9kZSkgJiYgbm9kZS5ob3N0IHx8XG4gIC8vIEZhbGxiYWNrLlxuICBnZXREb2N1bWVudEVsZW1lbnQobm9kZSk7XG4gIHJldHVybiBpc1NoYWRvd1Jvb3QocmVzdWx0KSA/IHJlc3VsdC5ob3N0IDogcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3Iobm9kZSkge1xuICBjb25zdCBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgaWYgKGlzTGFzdFRyYXZlcnNhYmxlTm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQgPyBub2RlLm93bmVyRG9jdW1lbnQuYm9keSA6IG5vZGUuYm9keTtcbiAgfVxuICBpZiAoaXNIVE1MRWxlbWVudChwYXJlbnROb2RlKSAmJiBpc092ZXJmbG93RWxlbWVudChwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvcihwYXJlbnROb2RlKTtcbn1cbmZ1bmN0aW9uIGdldE92ZXJmbG93QW5jZXN0b3JzKG5vZGUsIGxpc3QsIHRyYXZlcnNlSWZyYW1lcykge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDI7XG4gIGlmIChsaXN0ID09PSB2b2lkIDApIHtcbiAgICBsaXN0ID0gW107XG4gIH1cbiAgaWYgKHRyYXZlcnNlSWZyYW1lcyA9PT0gdm9pZCAwKSB7XG4gICAgdHJhdmVyc2VJZnJhbWVzID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQyID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudDIuYm9keSk7XG4gIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhzY3JvbGxhYmxlQW5jZXN0b3IpO1xuICBpZiAoaXNCb2R5KSB7XG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50KHdpbik7XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KHdpbiwgd2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc092ZXJmbG93RWxlbWVudChzY3JvbGxhYmxlQW5jZXN0b3IpID8gc2Nyb2xsYWJsZUFuY2VzdG9yIDogW10sIGZyYW1lRWxlbWVudCAmJiB0cmF2ZXJzZUlmcmFtZXMgPyBnZXRPdmVyZmxvd0FuY2VzdG9ycyhmcmFtZUVsZW1lbnQpIDogW10pO1xuICB9XG4gIHJldHVybiBsaXN0LmNvbmNhdChzY3JvbGxhYmxlQW5jZXN0b3IsIGdldE92ZXJmbG93QW5jZXN0b3JzKHNjcm9sbGFibGVBbmNlc3RvciwgW10sIHRyYXZlcnNlSWZyYW1lcykpO1xufVxuZnVuY3Rpb24gZ2V0RnJhbWVFbGVtZW50KHdpbikge1xuICByZXR1cm4gd2luLnBhcmVudCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yod2luLnBhcmVudCkgPyB3aW4uZnJhbWVFbGVtZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgZ2V0Q29udGFpbmluZ0Jsb2NrLCBnZXREb2N1bWVudEVsZW1lbnQsIGdldEZyYW1lRWxlbWVudCwgZ2V0TmVhcmVzdE92ZXJmbG93QW5jZXN0b3IsIGdldE5vZGVOYW1lLCBnZXROb2RlU2Nyb2xsLCBnZXRPdmVyZmxvd0FuY2VzdG9ycywgZ2V0UGFyZW50Tm9kZSwgZ2V0V2luZG93LCBpc0NvbnRhaW5pbmdCbG9jaywgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUsIGlzTm9kZSwgaXNPdmVyZmxvd0VsZW1lbnQsIGlzU2hhZG93Um9vdCwgaXNUYWJsZUVsZW1lbnQsIGlzVG9wTGF5ZXIsIGlzV2ViS2l0IH07XG4iXSwibmFtZXMiOlsiaGFzV2luZG93IiwiZ2V0Tm9kZU5hbWUiLCJub2RlIiwiaXNOb2RlIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldFdpbmRvdyIsIl9ub2RlJG93bmVyRG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJ3aW5kb3ciLCJnZXREb2N1bWVudEVsZW1lbnQiLCJfcmVmIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJ2YWx1ZSIsIk5vZGUiLCJpc0VsZW1lbnQiLCJFbGVtZW50IiwiaXNIVE1MRWxlbWVudCIsIkhUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImludmFsaWRPdmVyZmxvd0Rpc3BsYXlWYWx1ZXMiLCJTZXQiLCJpc092ZXJmbG93RWxlbWVudCIsImVsZW1lbnQiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwidGVzdCIsImhhcyIsInRhYmxlRWxlbWVudHMiLCJpc1RhYmxlRWxlbWVudCIsInRvcExheWVyU2VsZWN0b3JzIiwiaXNUb3BMYXllciIsInNvbWUiLCJzZWxlY3RvciIsIm1hdGNoZXMiLCJfZSIsInRyYW5zZm9ybVByb3BlcnRpZXMiLCJ3aWxsQ2hhbmdlVmFsdWVzIiwiY29udGFpblZhbHVlcyIsImlzQ29udGFpbmluZ0Jsb2NrIiwiZWxlbWVudE9yQ3NzIiwid2Via2l0IiwiaXNXZWJLaXQiLCJjc3MiLCJjb250YWluZXJUeXBlIiwiYmFja2Ryb3BGaWx0ZXIiLCJmaWx0ZXIiLCJ3aWxsQ2hhbmdlIiwiaW5jbHVkZXMiLCJjb250YWluIiwiZ2V0Q29udGFpbmluZ0Jsb2NrIiwiY3VycmVudE5vZGUiLCJnZXRQYXJlbnROb2RlIiwiaXNMYXN0VHJhdmVyc2FibGVOb2RlIiwiQ1NTIiwic3VwcG9ydHMiLCJsYXN0VHJhdmVyc2FibGVOb2RlTmFtZXMiLCJnZXROb2RlU2Nyb2xsIiwic2Nyb2xsTGVmdCIsInNjcm9sbFRvcCIsInNjcm9sbFgiLCJzY3JvbGxZIiwicmVzdWx0IiwiYXNzaWduZWRTbG90IiwicGFyZW50Tm9kZSIsImhvc3QiLCJnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3RvciIsImJvZHkiLCJnZXRPdmVyZmxvd0FuY2VzdG9ycyIsImxpc3QiLCJ0cmF2ZXJzZUlmcmFtZXMiLCJfbm9kZSRvd25lckRvY3VtZW50MiIsInNjcm9sbGFibGVBbmNlc3RvciIsImlzQm9keSIsIndpbiIsImZyYW1lRWxlbWVudCIsImdldEZyYW1lRWxlbWVudCIsImNvbmNhdCIsInZpc3VhbFZpZXdwb3J0IiwicGFyZW50IiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alignments: () => (/* binding */ alignments),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   createCoords: () => (/* binding */ createCoords),\n/* harmony export */   evaluate: () => (/* binding */ evaluate),\n/* harmony export */   expandPaddingObject: () => (/* binding */ expandPaddingObject),\n/* harmony export */   floor: () => (/* binding */ floor),\n/* harmony export */   getAlignment: () => (/* binding */ getAlignment),\n/* harmony export */   getAlignmentAxis: () => (/* binding */ getAlignmentAxis),\n/* harmony export */   getAlignmentSides: () => (/* binding */ getAlignmentSides),\n/* harmony export */   getAxisLength: () => (/* binding */ getAxisLength),\n/* harmony export */   getExpandedPlacements: () => (/* binding */ getExpandedPlacements),\n/* harmony export */   getOppositeAlignmentPlacement: () => (/* binding */ getOppositeAlignmentPlacement),\n/* harmony export */   getOppositeAxis: () => (/* binding */ getOppositeAxis),\n/* harmony export */   getOppositeAxisPlacements: () => (/* binding */ getOppositeAxisPlacements),\n/* harmony export */   getOppositePlacement: () => (/* binding */ getOppositePlacement),\n/* harmony export */   getPaddingObject: () => (/* binding */ getPaddingObject),\n/* harmony export */   getSide: () => (/* binding */ getSide),\n/* harmony export */   getSideAxis: () => (/* binding */ getSideAxis),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   placements: () => (/* binding */ placements),\n/* harmony export */   rectToClientRect: () => (/* binding */ rectToClientRect),\n/* harmony export */   round: () => (/* binding */ round),\n/* harmony export */   sides: () => (/* binding */ sides)\n/* harmony export */ });\n/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3V0aWxzL2Rpc3QvZmxvYXRpbmctdWkudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU1BLEtBQUssR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQztBQUNoRCxNQUFNQyxVQUFVLEdBQUcsQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDO0FBQ25DLE1BQU1DLFVBQVUsR0FBRyxhQUFhRixLQUFLLENBQUNHLE1BQU0sQ0FBQyxDQUFDQyxHQUFHLEVBQUVDLElBQUksS0FBS0QsR0FBRyxDQUFDRSxNQUFNLENBQUNELElBQUksRUFBRUEsSUFBSSxHQUFHLEdBQUcsR0FBR0osVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFSSxJQUFJLEdBQUcsR0FBRyxHQUFHSixVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDekksTUFBTU0sR0FBRyxHQUFHQyxJQUFJLENBQUNELEdBQUc7QUFDcEIsTUFBTUUsR0FBRyxHQUFHRCxJQUFJLENBQUNDLEdBQUc7QUFDcEIsTUFBTUMsS0FBSyxHQUFHRixJQUFJLENBQUNFLEtBQUs7QUFDeEIsTUFBTUMsS0FBSyxHQUFHSCxJQUFJLENBQUNHLEtBQUs7QUFDeEIsTUFBTUMsWUFBWSxHQUFHQyxDQUFDLEtBQUs7RUFDekJDLENBQUMsRUFBRUQsQ0FBQztFQUNKRSxDQUFDLEVBQUVGO0FBQ0wsQ0FBQyxDQUFDO0FBQ0YsTUFBTUcsZUFBZSxHQUFHO0VBQ3RCQyxJQUFJLEVBQUUsT0FBTztFQUNiQyxLQUFLLEVBQUUsTUFBTTtFQUNiQyxNQUFNLEVBQUUsS0FBSztFQUNiQyxHQUFHLEVBQUU7QUFDUCxDQUFDO0FBQ0QsTUFBTUMsb0JBQW9CLEdBQUc7RUFDM0JDLEtBQUssRUFBRSxLQUFLO0VBQ1pDLEdBQUcsRUFBRTtBQUNQ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ZmxvYXRpbmctdWkvdXRpbHMvZGlzdC9mbG9hdGluZy11aS51dGlscy5tanM/NWFlYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEN1c3RvbSBwb3NpdGlvbmluZyByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy92aXJ0dWFsLWVsZW1lbnRzXG4gKi9cblxuY29uc3Qgc2lkZXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuY29uc3QgYWxpZ25tZW50cyA9IFsnc3RhcnQnLCAnZW5kJ107XG5jb25zdCBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL3NpZGVzLnJlZHVjZSgoYWNjLCBzaWRlKSA9PiBhY2MuY29uY2F0KHNpZGUsIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMF0sIHNpZGUgKyBcIi1cIiArIGFsaWdubWVudHNbMV0pLCBbXSk7XG5jb25zdCBtaW4gPSBNYXRoLm1pbjtcbmNvbnN0IG1heCA9IE1hdGgubWF4O1xuY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kO1xuY29uc3QgZmxvb3IgPSBNYXRoLmZsb29yO1xuY29uc3QgY3JlYXRlQ29vcmRzID0gdiA9PiAoe1xuICB4OiB2LFxuICB5OiB2XG59KTtcbmNvbnN0IG9wcG9zaXRlU2lkZU1hcCA9IHtcbiAgbGVmdDogJ3JpZ2h0JyxcbiAgcmlnaHQ6ICdsZWZ0JyxcbiAgYm90dG9tOiAndG9wJyxcbiAgdG9wOiAnYm90dG9tJ1xufTtcbmNvbnN0IG9wcG9zaXRlQWxpZ25tZW50TWFwID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmZ1bmN0aW9uIGNsYW1wKHN0YXJ0LCB2YWx1ZSwgZW5kKSB7XG4gIHJldHVybiBtYXgoc3RhcnQsIG1pbih2YWx1ZSwgZW5kKSk7XG59XG5mdW5jdGlvbiBldmFsdWF0ZSh2YWx1ZSwgcGFyYW0pIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKHBhcmFtKSA6IHZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0U2lkZShwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0xlbmd0aChheGlzKSB7XG4gIHJldHVybiBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG59XG5jb25zdCB5QXhpc1NpZGVzID0gLyojX19QVVJFX18qL25ldyBTZXQoWyd0b3AnLCAnYm90dG9tJ10pO1xuZnVuY3Rpb24gZ2V0U2lkZUF4aXMocGxhY2VtZW50KSB7XG4gIHJldHVybiB5QXhpc1NpZGVzLmhhcyhnZXRTaWRlKHBsYWNlbWVudCkpID8gJ3knIDogJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25tZW50QXhpcyhwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGdldE9wcG9zaXRlQXhpcyhnZXRTaWRlQXhpcyhwbGFjZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudFNpZGVzKHBsYWNlbWVudCwgcmVjdHMsIHJ0bCkge1xuICBpZiAocnRsID09PSB2b2lkIDApIHtcbiAgICBydGwgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQocGxhY2VtZW50KTtcbiAgY29uc3QgYWxpZ25tZW50QXhpcyA9IGdldEFsaWdubWVudEF4aXMocGxhY2VtZW50KTtcbiAgY29uc3QgbGVuZ3RoID0gZ2V0QXhpc0xlbmd0aChhbGlnbm1lbnRBeGlzKTtcbiAgbGV0IG1haW5BbGlnbm1lbnRTaWRlID0gYWxpZ25tZW50QXhpcyA9PT0gJ3gnID8gYWxpZ25tZW50ID09PSAocnRsID8gJ2VuZCcgOiAnc3RhcnQnKSA/ICdyaWdodCcgOiAnbGVmdCcgOiBhbGlnbm1lbnQgPT09ICdzdGFydCcgPyAnYm90dG9tJyA6ICd0b3AnO1xuICBpZiAocmVjdHMucmVmZXJlbmNlW2xlbmd0aF0gPiByZWN0cy5mbG9hdGluZ1tsZW5ndGhdKSB7XG4gICAgbWFpbkFsaWdubWVudFNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluQWxpZ25tZW50U2lkZSk7XG4gIH1cbiAgcmV0dXJuIFttYWluQWxpZ25tZW50U2lkZSwgZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpbkFsaWdubWVudFNpZGUpXTtcbn1cbmZ1bmN0aW9uIGdldEV4cGFuZGVkUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgY29uc3Qgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGFsaWdubWVudCA9PiBvcHBvc2l0ZUFsaWdubWVudE1hcFthbGlnbm1lbnRdKTtcbn1cbmNvbnN0IGxyUGxhY2VtZW50ID0gWydsZWZ0JywgJ3JpZ2h0J107XG5jb25zdCBybFBsYWNlbWVudCA9IFsncmlnaHQnLCAnbGVmdCddO1xuY29uc3QgdGJQbGFjZW1lbnQgPSBbJ3RvcCcsICdib3R0b20nXTtcbmNvbnN0IGJ0UGxhY2VtZW50ID0gWydib3R0b20nLCAndG9wJ107XG5mdW5jdGlvbiBnZXRTaWRlTGlzdChzaWRlLCBpc1N0YXJ0LCBydGwpIHtcbiAgc3dpdGNoIChzaWRlKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgaWYgKHJ0bCkgcmV0dXJuIGlzU3RhcnQgPyBybFBsYWNlbWVudCA6IGxyUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGlzU3RhcnQgPyBsclBsYWNlbWVudCA6IHJsUGxhY2VtZW50O1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHJldHVybiBpc1N0YXJ0ID8gdGJQbGFjZW1lbnQgOiBidFBsYWNlbWVudDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzKHBsYWNlbWVudCwgZmxpcEFsaWdubWVudCwgZGlyZWN0aW9uLCBydGwpIHtcbiAgY29uc3QgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KHBsYWNlbWVudCk7XG4gIGxldCBsaXN0ID0gZ2V0U2lkZUxpc3QoZ2V0U2lkZShwbGFjZW1lbnQpLCBkaXJlY3Rpb24gPT09ICdzdGFydCcsIHJ0bCk7XG4gIGlmIChhbGlnbm1lbnQpIHtcbiAgICBsaXN0ID0gbGlzdC5tYXAoc2lkZSA9PiBzaWRlICsgXCItXCIgKyBhbGlnbm1lbnQpO1xuICAgIGlmIChmbGlwQWxpZ25tZW50KSB7XG4gICAgICBsaXN0ID0gbGlzdC5jb25jYXQobGlzdC5tYXAoZ2V0T3Bwb3NpdGVBbGlnbm1lbnRQbGFjZW1lbnQpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgc2lkZSA9PiBvcHBvc2l0ZVNpZGVNYXBbc2lkZV0pO1xufVxuZnVuY3Rpb24gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwLFxuICAgIC4uLnBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFBhZGRpbmdPYmplY3QocGFkZGluZykge1xuICByZXR1cm4gdHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gZXhwYW5kUGFkZGluZ09iamVjdChwYWRkaW5nKSA6IHtcbiAgICB0b3A6IHBhZGRpbmcsXG4gICAgcmlnaHQ6IHBhZGRpbmcsXG4gICAgYm90dG9tOiBwYWRkaW5nLFxuICAgIGxlZnQ6IHBhZGRpbmdcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gcmVjdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5cbmV4cG9ydCB7IGFsaWdubWVudHMsIGNsYW1wLCBjcmVhdGVDb29yZHMsIGV2YWx1YXRlLCBleHBhbmRQYWRkaW5nT2JqZWN0LCBmbG9vciwgZ2V0QWxpZ25tZW50LCBnZXRBbGlnbm1lbnRBeGlzLCBnZXRBbGlnbm1lbnRTaWRlcywgZ2V0QXhpc0xlbmd0aCwgZ2V0RXhwYW5kZWRQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZUFsaWdubWVudFBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVBeGlzLCBnZXRPcHBvc2l0ZUF4aXNQbGFjZW1lbnRzLCBnZXRPcHBvc2l0ZVBsYWNlbWVudCwgZ2V0UGFkZGluZ09iamVjdCwgZ2V0U2lkZSwgZ2V0U2lkZUF4aXMsIG1heCwgbWluLCBwbGFjZW1lbnRzLCByZWN0VG9DbGllbnRSZWN0LCByb3VuZCwgc2lkZXMgfTtcbiJdLCJuYW1lcyI6WyJzaWRlcyIsImFsaWdubWVudHMiLCJwbGFjZW1lbnRzIiwicmVkdWNlIiwiYWNjIiwic2lkZSIsImNvbmNhdCIsIm1pbiIsIk1hdGgiLCJtYXgiLCJyb3VuZCIsImZsb29yIiwiY3JlYXRlQ29vcmRzIiwidiIsIngiLCJ5Iiwib3Bwb3NpdGVTaWRlTWFwIiwibGVmdCIsInJpZ2h0IiwiYm90dG9tIiwidG9wIiwib3Bwb3NpdGVBbGlnbm1lbnRNYXAiLCJzdGFydCIsImVuZCIsImNsYW1wIiwidmFsdWUiLCJldmFsdWF0ZSIsInBhcmFtIiwiZ2V0U2lkZSIsInBsYWNlbWVudCIsInNwbGl0IiwiZ2V0QWxpZ25tZW50IiwiZ2V0T3Bwb3NpdGVBeGlzIiwiYXhpcyIsImdldEF4aXNMZW5ndGgiLCJ5QXhpc1NpZGVzIiwiU2V0IiwiZ2V0U2lkZUF4aXMiLCJoYXMiLCJnZXRBbGlnbm1lbnRBeGlzIiwiZ2V0QWxpZ25tZW50U2lkZXMiLCJyZWN0cyIsInJ0bCIsImFsaWdubWVudCIsImFsaWdubWVudEF4aXMiLCJsZW5ndGgiLCJtYWluQWxpZ25tZW50U2lkZSIsInJlZmVyZW5jZSIsImZsb2F0aW5nIiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJnZXRFeHBhbmRlZFBsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImdldE9wcG9zaXRlQWxpZ25tZW50UGxhY2VtZW50IiwicmVwbGFjZSIsImxyUGxhY2VtZW50IiwicmxQbGFjZW1lbnQiLCJ0YlBsYWNlbWVudCIsImJ0UGxhY2VtZW50IiwiZ2V0U2lkZUxpc3QiLCJpc1N0YXJ0IiwiZ2V0T3Bwb3NpdGVBeGlzUGxhY2VtZW50cyIsImZsaXBBbGlnbm1lbnQiLCJkaXJlY3Rpb24iLCJsaXN0IiwibWFwIiwiZXhwYW5kUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJnZXRQYWRkaW5nT2JqZWN0IiwicmVjdFRvQ2xpZW50UmVjdCIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\n");

/***/ })

};
;